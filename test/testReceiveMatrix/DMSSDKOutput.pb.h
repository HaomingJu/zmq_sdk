// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DMSSDKOutput.proto

#ifndef PROTOBUF_DMSSDKOutput_2eproto__INCLUDED
#define PROTOBUF_DMSSDKOutput_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DMSOutputProtocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_DMSSDKOutput_2eproto();
void protobuf_AssignDesc_DMSSDKOutput_2eproto();
void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

class Rect;
class Vector_3f;
class Point;
class StateTrigger;
class EyeScore;
class SmokeScore;
class RotRPY;
class RotVector;
class FaceDirection;
class EventResult;
class DAAResult;
class StateResult;
class LDMK;
class EyeResult;
class SmokeResult;
class FaceROI;
class FaceInfo;
class PersonInfo;
class VisionPercept;
class PerceptResult;

enum ImageCheckEnum {
  IMAGE_CHECK_NORMAL = 0,
  IMAGE_CHECK_BLURRED = 1,
  IMAGE_CHECK_SHELTER = 2,
  IMAGE_CHECK_FREEZED = 3
};
bool ImageCheckEnum_IsValid(int value);
const ImageCheckEnum ImageCheckEnum_MIN = IMAGE_CHECK_NORMAL;
const ImageCheckEnum ImageCheckEnum_MAX = IMAGE_CHECK_FREEZED;
const int ImageCheckEnum_ARRAYSIZE = ImageCheckEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor *ImageCheckEnum_descriptor();
inline const ::std::string &ImageCheckEnum_Name(ImageCheckEnum value) {
  return ::google::protobuf::internal::NameOfEnum(ImageCheckEnum_descriptor(),
                                                  value);
}
inline bool ImageCheckEnum_Parse(const ::std::string &name,
                                 ImageCheckEnum *value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageCheckEnum>(
      ImageCheckEnum_descriptor(), name, value);
}
enum EyeState { EYE_ST_UNKNOW = 0, EYE_ST_OPEN = 1, EYE_ST_CLOSE = 2 };
bool EyeState_IsValid(int value);
const EyeState EyeState_MIN = EYE_ST_UNKNOW;
const EyeState EyeState_MAX = EYE_ST_CLOSE;
const int EyeState_ARRAYSIZE = EyeState_MAX + 1;

const ::google::protobuf::EnumDescriptor *EyeState_descriptor();
inline const ::std::string &EyeState_Name(EyeState value) {
  return ::google::protobuf::internal::NameOfEnum(EyeState_descriptor(), value);
}
inline bool EyeState_Parse(const ::std::string &name, EyeState *value) {
  return ::google::protobuf::internal::ParseNamedEnum<EyeState>(
      EyeState_descriptor(), name, value);
}
enum SmokeState {
  SMOKE_ST_UNKNOW = 0,
  SMOKE_ST_EXIST = 1,
  SMOKE_ST_NOEXIST = 2
};
bool SmokeState_IsValid(int value);
const SmokeState SmokeState_MIN = SMOKE_ST_UNKNOW;
const SmokeState SmokeState_MAX = SMOKE_ST_NOEXIST;
const int SmokeState_ARRAYSIZE = SmokeState_MAX + 1;

const ::google::protobuf::EnumDescriptor *SmokeState_descriptor();
inline const ::std::string &SmokeState_Name(SmokeState value) {
  return ::google::protobuf::internal::NameOfEnum(SmokeState_descriptor(),
                                                  value);
}
inline bool SmokeState_Parse(const ::std::string &name, SmokeState *value) {
  return ::google::protobuf::internal::ParseNamedEnum<SmokeState>(
      SmokeState_descriptor(), name, value);
}
enum StateEnum {
  STATE_NONE = 0,
  STATE_DDW_L = 1,
  STATE_DDW_R = 2,
  STATE_DDW_U = 3,
  STATE_DDW_D = 4,
  STATE_DDW_LU = 5,
  STATE_DDW_RU = 6,
  STATE_DDW_LD = 7,
  STATE_DDW_RD = 8,
  STATE_DFW = 9,
  STATE_DYA = 10,
  STATE_DCA = 11,
  STATE_DSA = 12,
  STATE_DAA = 13
};
bool StateEnum_IsValid(int value);
const StateEnum StateEnum_MIN = STATE_NONE;
const StateEnum StateEnum_MAX = STATE_DAA;
const int StateEnum_ARRAYSIZE = StateEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor *StateEnum_descriptor();
inline const ::std::string &StateEnum_Name(StateEnum value) {
  return ::google::protobuf::internal::NameOfEnum(StateEnum_descriptor(),
                                                  value);
}
inline bool StateEnum_Parse(const ::std::string &name, StateEnum *value) {
  return ::google::protobuf::internal::ParseNamedEnum<StateEnum>(
      StateEnum_descriptor(), name, value);
}
enum EventEnum {
  EVENT_NONE = 0,
  EVENT_DDW_L = 1,
  EVENT_DDW_R = 2,
  EVENT_DDW_U = 3,
  EVENT_DDW_D = 4,
  EVENT_DDW_LU = 5,
  EVENT_DDW_RU = 6,
  EVENT_DDW_LD = 7,
  EVENT_DDW_RD = 8,
  EVENT_DFW = 9,
  EVENT_DYA = 10,
  EVENT_DCA = 11,
  EVENT_DSA = 12,
  EVENT_DAA = 13
};
bool EventEnum_IsValid(int value);
const EventEnum EventEnum_MIN = EVENT_NONE;
const EventEnum EventEnum_MAX = EVENT_DAA;
const int EventEnum_ARRAYSIZE = EventEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor *EventEnum_descriptor();
inline const ::std::string &EventEnum_Name(EventEnum value) {
  return ::google::protobuf::internal::NameOfEnum(EventEnum_descriptor(),
                                                  value);
}
inline bool EventEnum_Parse(const ::std::string &name, EventEnum *value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventEnum>(
      EventEnum_descriptor(), name, value);
}
enum FaceDirEnum {
  FACE_DIR_UNKNOW = 0,
  FACE_DIR_FRONT = 1,
  FACE_DIR_LEFT = 2,
  FACE_DIR_RIGHT = 4,
  FACE_DIR_UP = 8,
  FACE_DIR_DOWN = 16,
  FACE_DIR_LEFTUP = 10,
  FACE_DIR_RIGHTUP = 12,
  FACE_DIR_LEFTDOWN = 18,
  FACE_DIR_RIGHTDOWN = 20
};
bool FaceDirEnum_IsValid(int value);
const FaceDirEnum FaceDirEnum_MIN = FACE_DIR_UNKNOW;
const FaceDirEnum FaceDirEnum_MAX = FACE_DIR_RIGHTDOWN;
const int FaceDirEnum_ARRAYSIZE = FaceDirEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor *FaceDirEnum_descriptor();
inline const ::std::string &FaceDirEnum_Name(FaceDirEnum value) {
  return ::google::protobuf::internal::NameOfEnum(FaceDirEnum_descriptor(),
                                                  value);
}
inline bool FaceDirEnum_Parse(const ::std::string &name, FaceDirEnum *value) {
  return ::google::protobuf::internal::ParseNamedEnum<FaceDirEnum>(
      FaceDirEnum_descriptor(), name, value);
}
enum PersonType {
  PERSON_UNKNOW = 0,
  PERSON_DRIVER = 1,
  PERSON_COPILOT = 2,
  PERSON_PASSENGER = 3
};
bool PersonType_IsValid(int value);
const PersonType PersonType_MIN = PERSON_UNKNOW;
const PersonType PersonType_MAX = PERSON_PASSENGER;
const int PersonType_ARRAYSIZE = PersonType_MAX + 1;

const ::google::protobuf::EnumDescriptor *PersonType_descriptor();
inline const ::std::string &PersonType_Name(PersonType value) {
  return ::google::protobuf::internal::NameOfEnum(PersonType_descriptor(),
                                                  value);
}
inline bool PersonType_Parse(const ::std::string &name, PersonType *value) {
  return ::google::protobuf::internal::ParseNamedEnum<PersonType>(
      PersonType_descriptor(), name, value);
}
enum CameraType { CAMERA_IR = 0, CAMERA_RGB = 1, CAMERA_SIZE = 2 };
bool CameraType_IsValid(int value);
const CameraType CameraType_MIN = CAMERA_IR;
const CameraType CameraType_MAX = CAMERA_SIZE;
const int CameraType_ARRAYSIZE = CameraType_MAX + 1;

const ::google::protobuf::EnumDescriptor *CameraType_descriptor();
inline const ::std::string &CameraType_Name(CameraType value) {
  return ::google::protobuf::internal::NameOfEnum(CameraType_descriptor(),
                                                  value);
}
inline bool CameraType_Parse(const ::std::string &name, CameraType *value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraType>(
      CameraType_descriptor(), name, value);
}
// ===================================================================

class Rect : public ::google::protobuf::Message {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect &from);

  inline Rect &operator=(const Rect &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const Rect &default_instance();

  void Swap(Rect *other);

  // implements Message ----------------------------------------------

  Rect *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const Rect &from);
  void MergeFrom(const Rect &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required int32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required int32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.Rect)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static Rect *default_instance_;
};
// -------------------------------------------------------------------

class Vector_3f : public ::google::protobuf::Message {
 public:
  Vector_3f();
  virtual ~Vector_3f();

  Vector_3f(const Vector_3f &from);

  inline Vector_3f &operator=(const Vector_3f &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const Vector_3f &default_instance();

  void Swap(Vector_3f *other);

  // implements Message ----------------------------------------------

  Vector_3f *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const Vector_3f &from);
  void MergeFrom(const Vector_3f &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.Vector_3f)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static Vector_3f *default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point &from);

  inline Point &operator=(const Point &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const Point &default_instance();

  void Swap(Point *other);

  // implements Message ----------------------------------------------

  Point *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const Point &from);
  void MergeFrom(const Point &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static Point *default_instance_;
};
// -------------------------------------------------------------------

class StateTrigger : public ::google::protobuf::Message {
 public:
  StateTrigger();
  virtual ~StateTrigger();

  StateTrigger(const StateTrigger &from);

  inline StateTrigger &operator=(const StateTrigger &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const StateTrigger &default_instance();

  void Swap(StateTrigger *other);

  // implements Message ----------------------------------------------

  StateTrigger *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const StateTrigger &from);
  void MergeFrom(const StateTrigger &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.StateEnum ddw_l = 1;
  inline bool has_ddw_l() const;
  inline void clear_ddw_l();
  static const int kDdwLFieldNumber = 1;
  inline ::DMSOutputProtocol::StateEnum ddw_l() const;
  inline void set_ddw_l(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum ddw_r = 2;
  inline bool has_ddw_r() const;
  inline void clear_ddw_r();
  static const int kDdwRFieldNumber = 2;
  inline ::DMSOutputProtocol::StateEnum ddw_r() const;
  inline void set_ddw_r(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum ddw_u = 3;
  inline bool has_ddw_u() const;
  inline void clear_ddw_u();
  static const int kDdwUFieldNumber = 3;
  inline ::DMSOutputProtocol::StateEnum ddw_u() const;
  inline void set_ddw_u(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum ddw_d = 4;
  inline bool has_ddw_d() const;
  inline void clear_ddw_d();
  static const int kDdwDFieldNumber = 4;
  inline ::DMSOutputProtocol::StateEnum ddw_d() const;
  inline void set_ddw_d(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum ddw_lu = 5;
  inline bool has_ddw_lu() const;
  inline void clear_ddw_lu();
  static const int kDdwLuFieldNumber = 5;
  inline ::DMSOutputProtocol::StateEnum ddw_lu() const;
  inline void set_ddw_lu(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum ddw_ld = 6;
  inline bool has_ddw_ld() const;
  inline void clear_ddw_ld();
  static const int kDdwLdFieldNumber = 6;
  inline ::DMSOutputProtocol::StateEnum ddw_ld() const;
  inline void set_ddw_ld(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum ddw_ru = 7;
  inline bool has_ddw_ru() const;
  inline void clear_ddw_ru();
  static const int kDdwRuFieldNumber = 7;
  inline ::DMSOutputProtocol::StateEnum ddw_ru() const;
  inline void set_ddw_ru(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum ddw_rd = 8;
  inline bool has_ddw_rd() const;
  inline void clear_ddw_rd();
  static const int kDdwRdFieldNumber = 8;
  inline ::DMSOutputProtocol::StateEnum ddw_rd() const;
  inline void set_ddw_rd(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum dfw = 9;
  inline bool has_dfw() const;
  inline void clear_dfw();
  static const int kDfwFieldNumber = 9;
  inline ::DMSOutputProtocol::StateEnum dfw() const;
  inline void set_dfw(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum dya = 10;
  inline bool has_dya() const;
  inline void clear_dya();
  static const int kDyaFieldNumber = 10;
  inline ::DMSOutputProtocol::StateEnum dya() const;
  inline void set_dya(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum dca = 11;
  inline bool has_dca() const;
  inline void clear_dca();
  static const int kDcaFieldNumber = 11;
  inline ::DMSOutputProtocol::StateEnum dca() const;
  inline void set_dca(::DMSOutputProtocol::StateEnum value);

  // required .DMSOutputProtocol.StateEnum dsa = 12;
  inline bool has_dsa() const;
  inline void clear_dsa();
  static const int kDsaFieldNumber = 12;
  inline ::DMSOutputProtocol::StateEnum dsa() const;
  inline void set_dsa(::DMSOutputProtocol::StateEnum value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.StateTrigger)
 private:
  inline void set_has_ddw_l();
  inline void clear_has_ddw_l();
  inline void set_has_ddw_r();
  inline void clear_has_ddw_r();
  inline void set_has_ddw_u();
  inline void clear_has_ddw_u();
  inline void set_has_ddw_d();
  inline void clear_has_ddw_d();
  inline void set_has_ddw_lu();
  inline void clear_has_ddw_lu();
  inline void set_has_ddw_ld();
  inline void clear_has_ddw_ld();
  inline void set_has_ddw_ru();
  inline void clear_has_ddw_ru();
  inline void set_has_ddw_rd();
  inline void clear_has_ddw_rd();
  inline void set_has_dfw();
  inline void clear_has_dfw();
  inline void set_has_dya();
  inline void clear_has_dya();
  inline void set_has_dca();
  inline void clear_has_dca();
  inline void set_has_dsa();
  inline void clear_has_dsa();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int ddw_l_;
  int ddw_r_;
  int ddw_u_;
  int ddw_d_;
  int ddw_lu_;
  int ddw_ld_;
  int ddw_ru_;
  int ddw_rd_;
  int dfw_;
  int dya_;
  int dca_;
  int dsa_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static StateTrigger *default_instance_;
};
// -------------------------------------------------------------------

class EyeScore : public ::google::protobuf::Message {
 public:
  EyeScore();
  virtual ~EyeScore();

  EyeScore(const EyeScore &from);

  inline EyeScore &operator=(const EyeScore &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const EyeScore &default_instance();

  void Swap(EyeScore *other);

  // implements Message ----------------------------------------------

  EyeScore *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const EyeScore &from);
  void MergeFrom(const EyeScore &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float left_open_score = 1;
  inline bool has_left_open_score() const;
  inline void clear_left_open_score();
  static const int kLeftOpenScoreFieldNumber = 1;
  inline float left_open_score() const;
  inline void set_left_open_score(float value);

  // required float left_close_score = 2;
  inline bool has_left_close_score() const;
  inline void clear_left_close_score();
  static const int kLeftCloseScoreFieldNumber = 2;
  inline float left_close_score() const;
  inline void set_left_close_score(float value);

  // required float left_unknow_score = 3;
  inline bool has_left_unknow_score() const;
  inline void clear_left_unknow_score();
  static const int kLeftUnknowScoreFieldNumber = 3;
  inline float left_unknow_score() const;
  inline void set_left_unknow_score(float value);

  // required float right_open_score = 4;
  inline bool has_right_open_score() const;
  inline void clear_right_open_score();
  static const int kRightOpenScoreFieldNumber = 4;
  inline float right_open_score() const;
  inline void set_right_open_score(float value);

  // required float right_close_score = 5;
  inline bool has_right_close_score() const;
  inline void clear_right_close_score();
  static const int kRightCloseScoreFieldNumber = 5;
  inline float right_close_score() const;
  inline void set_right_close_score(float value);

  // required float right_unknow_score = 6;
  inline bool has_right_unknow_score() const;
  inline void clear_right_unknow_score();
  static const int kRightUnknowScoreFieldNumber = 6;
  inline float right_unknow_score() const;
  inline void set_right_unknow_score(float value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.EyeScore)
 private:
  inline void set_has_left_open_score();
  inline void clear_has_left_open_score();
  inline void set_has_left_close_score();
  inline void clear_has_left_close_score();
  inline void set_has_left_unknow_score();
  inline void clear_has_left_unknow_score();
  inline void set_has_right_open_score();
  inline void clear_has_right_open_score();
  inline void set_has_right_close_score();
  inline void clear_has_right_close_score();
  inline void set_has_right_unknow_score();
  inline void clear_has_right_unknow_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float left_open_score_;
  float left_close_score_;
  float left_unknow_score_;
  float right_open_score_;
  float right_close_score_;
  float right_unknow_score_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static EyeScore *default_instance_;
};
// -------------------------------------------------------------------

class SmokeScore : public ::google::protobuf::Message {
 public:
  SmokeScore();
  virtual ~SmokeScore();

  SmokeScore(const SmokeScore &from);

  inline SmokeScore &operator=(const SmokeScore &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const SmokeScore &default_instance();

  void Swap(SmokeScore *other);

  // implements Message ----------------------------------------------

  SmokeScore *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const SmokeScore &from);
  void MergeFrom(const SmokeScore &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float no_smoke_normal = 1;
  inline bool has_no_smoke_normal() const;
  inline void clear_no_smoke_normal();
  static const int kNoSmokeNormalFieldNumber = 1;
  inline float no_smoke_normal() const;
  inline void set_no_smoke_normal(float value);

  // required float smoke_normal = 2;
  inline bool has_smoke_normal() const;
  inline void clear_smoke_normal();
  static const int kSmokeNormalFieldNumber = 2;
  inline float smoke_normal() const;
  inline void set_smoke_normal(float value);

  // required float no_smoke_suspect = 3;
  inline bool has_no_smoke_suspect() const;
  inline void clear_no_smoke_suspect();
  static const int kNoSmokeSuspectFieldNumber = 3;
  inline float no_smoke_suspect() const;
  inline void set_no_smoke_suspect(float value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.SmokeScore)
 private:
  inline void set_has_no_smoke_normal();
  inline void clear_has_no_smoke_normal();
  inline void set_has_smoke_normal();
  inline void clear_has_smoke_normal();
  inline void set_has_no_smoke_suspect();
  inline void clear_has_no_smoke_suspect();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float no_smoke_normal_;
  float smoke_normal_;
  float no_smoke_suspect_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static SmokeScore *default_instance_;
};
// -------------------------------------------------------------------

class RotRPY : public ::google::protobuf::Message {
 public:
  RotRPY();
  virtual ~RotRPY();

  RotRPY(const RotRPY &from);

  inline RotRPY &operator=(const RotRPY &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const RotRPY &default_instance();

  void Swap(RotRPY *other);

  // implements Message ----------------------------------------------

  RotRPY *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const RotRPY &from);
  void MergeFrom(const RotRPY &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float roll = 1;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 1;
  inline float roll() const;
  inline void set_roll(float value);

  // required float pitch = 2;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 2;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float yaw = 3;
  inline bool has_yaw() const;
  inline void clear_yaw();
  static const int kYawFieldNumber = 3;
  inline float yaw() const;
  inline void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.RotRPY)
 private:
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_yaw();
  inline void clear_has_yaw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float roll_;
  float pitch_;
  float yaw_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static RotRPY *default_instance_;
};
// -------------------------------------------------------------------

class RotVector : public ::google::protobuf::Message {
 public:
  RotVector();
  virtual ~RotVector();

  RotVector(const RotVector &from);

  inline RotVector &operator=(const RotVector &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const RotVector &default_instance();

  void Swap(RotVector *other);

  // implements Message ----------------------------------------------

  RotVector *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const RotVector &from);
  void MergeFrom(const RotVector &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.Vector_3f unit_vector = 1;
  inline bool has_unit_vector() const;
  inline void clear_unit_vector();
  static const int kUnitVectorFieldNumber = 1;
  inline const ::DMSOutputProtocol::Vector_3f &unit_vector() const;
  inline ::DMSOutputProtocol::Vector_3f *mutable_unit_vector();
  inline ::DMSOutputProtocol::Vector_3f *release_unit_vector();
  inline void set_allocated_unit_vector(
      ::DMSOutputProtocol::Vector_3f *unit_vector);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.RotVector)
 private:
  inline void set_has_unit_vector();
  inline void clear_has_unit_vector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DMSOutputProtocol::Vector_3f *unit_vector_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static RotVector *default_instance_;
};
// -------------------------------------------------------------------

class FaceDirection : public ::google::protobuf::Message {
 public:
  FaceDirection();
  virtual ~FaceDirection();

  FaceDirection(const FaceDirection &from);

  inline FaceDirection &operator=(const FaceDirection &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const FaceDirection &default_instance();

  void Swap(FaceDirection *other);

  // implements Message ----------------------------------------------

  FaceDirection *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const FaceDirection &from);
  void MergeFrom(const FaceDirection &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.FaceDirEnum face_dir = 1;
  inline bool has_face_dir() const;
  inline void clear_face_dir();
  static const int kFaceDirFieldNumber = 1;
  inline ::DMSOutputProtocol::FaceDirEnum face_dir() const;
  inline void set_face_dir(::DMSOutputProtocol::FaceDirEnum value);

  // optional .DMSOutputProtocol.RotRPY cur_angle_rpy = 2;
  inline bool has_cur_angle_rpy() const;
  inline void clear_cur_angle_rpy();
  static const int kCurAngleRpyFieldNumber = 2;
  inline const ::DMSOutputProtocol::RotRPY &cur_angle_rpy() const;
  inline ::DMSOutputProtocol::RotRPY *mutable_cur_angle_rpy();
  inline ::DMSOutputProtocol::RotRPY *release_cur_angle_rpy();
  inline void set_allocated_cur_angle_rpy(
      ::DMSOutputProtocol::RotRPY *cur_angle_rpy);

  // optional .DMSOutputProtocol.RotRPY avr_angle_rpy = 3;
  inline bool has_avr_angle_rpy() const;
  inline void clear_avr_angle_rpy();
  static const int kAvrAngleRpyFieldNumber = 3;
  inline const ::DMSOutputProtocol::RotRPY &avr_angle_rpy() const;
  inline ::DMSOutputProtocol::RotRPY *mutable_avr_angle_rpy();
  inline ::DMSOutputProtocol::RotRPY *release_avr_angle_rpy();
  inline void set_allocated_avr_angle_rpy(
      ::DMSOutputProtocol::RotRPY *avr_angle_rpy);

  // optional .DMSOutputProtocol.RotVector cur_angle_unit_vector = 4;
  inline bool has_cur_angle_unit_vector() const;
  inline void clear_cur_angle_unit_vector();
  static const int kCurAngleUnitVectorFieldNumber = 4;
  inline const ::DMSOutputProtocol::RotVector &cur_angle_unit_vector() const;
  inline ::DMSOutputProtocol::RotVector *mutable_cur_angle_unit_vector();
  inline ::DMSOutputProtocol::RotVector *release_cur_angle_unit_vector();
  inline void set_allocated_cur_angle_unit_vector(
      ::DMSOutputProtocol::RotVector *cur_angle_unit_vector);

  // optional .DMSOutputProtocol.RotVector avr_angle_unit_vector = 5;
  inline bool has_avr_angle_unit_vector() const;
  inline void clear_avr_angle_unit_vector();
  static const int kAvrAngleUnitVectorFieldNumber = 5;
  inline const ::DMSOutputProtocol::RotVector &avr_angle_unit_vector() const;
  inline ::DMSOutputProtocol::RotVector *mutable_avr_angle_unit_vector();
  inline ::DMSOutputProtocol::RotVector *release_avr_angle_unit_vector();
  inline void set_allocated_avr_angle_unit_vector(
      ::DMSOutputProtocol::RotVector *avr_angle_unit_vector);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.FaceDirection)
 private:
  inline void set_has_face_dir();
  inline void clear_has_face_dir();
  inline void set_has_cur_angle_rpy();
  inline void clear_has_cur_angle_rpy();
  inline void set_has_avr_angle_rpy();
  inline void clear_has_avr_angle_rpy();
  inline void set_has_cur_angle_unit_vector();
  inline void clear_has_cur_angle_unit_vector();
  inline void set_has_avr_angle_unit_vector();
  inline void clear_has_avr_angle_unit_vector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DMSOutputProtocol::RotRPY *cur_angle_rpy_;
  ::DMSOutputProtocol::RotRPY *avr_angle_rpy_;
  ::DMSOutputProtocol::RotVector *cur_angle_unit_vector_;
  ::DMSOutputProtocol::RotVector *avr_angle_unit_vector_;
  int face_dir_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static FaceDirection *default_instance_;
};
// -------------------------------------------------------------------

class EventResult : public ::google::protobuf::Message {
 public:
  EventResult();
  virtual ~EventResult();

  EventResult(const EventResult &from);

  inline EventResult &operator=(const EventResult &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const EventResult &default_instance();

  void Swap(EventResult *other);

  // implements Message ----------------------------------------------

  EventResult *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const EventResult &from);
  void MergeFrom(const EventResult &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.EventEnum event = 1;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline ::DMSOutputProtocol::EventEnum event() const;
  inline void set_event(::DMSOutputProtocol::EventEnum value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.EventResult)
 private:
  inline void set_has_event();
  inline void clear_has_event();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int event_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static EventResult *default_instance_;
};
// -------------------------------------------------------------------

class DAAResult : public ::google::protobuf::Message {
 public:
  DAAResult();
  virtual ~DAAResult();

  DAAResult(const DAAResult &from);

  inline DAAResult &operator=(const DAAResult &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const DAAResult &default_instance();

  void Swap(DAAResult *other);

  // implements Message ----------------------------------------------

  DAAResult *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const DAAResult &from);
  void MergeFrom(const DAAResult &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.EventEnum daa_event = 1;
  inline bool has_daa_event() const;
  inline void clear_daa_event();
  static const int kDaaEventFieldNumber = 1;
  inline ::DMSOutputProtocol::EventEnum daa_event() const;
  inline void set_daa_event(::DMSOutputProtocol::EventEnum value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.DAAResult)
 private:
  inline void set_has_daa_event();
  inline void clear_has_daa_event();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int daa_event_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static DAAResult *default_instance_;
};
// -------------------------------------------------------------------

class StateResult : public ::google::protobuf::Message {
 public:
  StateResult();
  virtual ~StateResult();

  StateResult(const StateResult &from);

  inline StateResult &operator=(const StateResult &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const StateResult &default_instance();

  void Swap(StateResult *other);

  // implements Message ----------------------------------------------

  StateResult *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const StateResult &from);
  void MergeFrom(const StateResult &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.StateEnum state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::DMSOutputProtocol::StateEnum state() const;
  inline void set_state(::DMSOutputProtocol::StateEnum value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.StateResult)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int state_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static StateResult *default_instance_;
};
// -------------------------------------------------------------------

class LDMK : public ::google::protobuf::Message {
 public:
  LDMK();
  virtual ~LDMK();

  LDMK(const LDMK &from);

  inline LDMK &operator=(const LDMK &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const LDMK &default_instance();

  void Swap(LDMK *other);

  // implements Message ----------------------------------------------

  LDMK *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const LDMK &from);
  void MergeFrom(const LDMK &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DMSOutputProtocol.Point face_feature_points = 1;
  inline int face_feature_points_size() const;
  inline void clear_face_feature_points();
  static const int kFaceFeaturePointsFieldNumber = 1;
  inline const ::DMSOutputProtocol::Point &face_feature_points(int index) const;
  inline ::DMSOutputProtocol::Point *mutable_face_feature_points(int index);
  inline ::DMSOutputProtocol::Point *add_face_feature_points();
  inline const ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::Point>
      &face_feature_points() const;
  inline ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::Point>
      *mutable_face_feature_points();

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.LDMK)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::Point>
      face_feature_points_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static LDMK *default_instance_;
};
// -------------------------------------------------------------------

class EyeResult : public ::google::protobuf::Message {
 public:
  EyeResult();
  virtual ~EyeResult();

  EyeResult(const EyeResult &from);

  inline EyeResult &operator=(const EyeResult &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const EyeResult &default_instance();

  void Swap(EyeResult *other);

  // implements Message ----------------------------------------------

  EyeResult *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const EyeResult &from);
  void MergeFrom(const EyeResult &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.EyeState left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::DMSOutputProtocol::EyeState left() const;
  inline void set_left(::DMSOutputProtocol::EyeState value);

  // required .DMSOutputProtocol.EyeState right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::DMSOutputProtocol::EyeState right() const;
  inline void set_right(::DMSOutputProtocol::EyeState value);

  // required .DMSOutputProtocol.Rect left_roi = 3;
  inline bool has_left_roi() const;
  inline void clear_left_roi();
  static const int kLeftRoiFieldNumber = 3;
  inline const ::DMSOutputProtocol::Rect &left_roi() const;
  inline ::DMSOutputProtocol::Rect *mutable_left_roi();
  inline ::DMSOutputProtocol::Rect *release_left_roi();
  inline void set_allocated_left_roi(::DMSOutputProtocol::Rect *left_roi);

  // required .DMSOutputProtocol.Rect right_roi = 4;
  inline bool has_right_roi() const;
  inline void clear_right_roi();
  static const int kRightRoiFieldNumber = 4;
  inline const ::DMSOutputProtocol::Rect &right_roi() const;
  inline ::DMSOutputProtocol::Rect *mutable_right_roi();
  inline ::DMSOutputProtocol::Rect *release_right_roi();
  inline void set_allocated_right_roi(::DMSOutputProtocol::Rect *right_roi);

  // optional .DMSOutputProtocol.EyeScore score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline const ::DMSOutputProtocol::EyeScore &score() const;
  inline ::DMSOutputProtocol::EyeScore *mutable_score();
  inline ::DMSOutputProtocol::EyeScore *release_score();
  inline void set_allocated_score(::DMSOutputProtocol::EyeScore *score);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.EyeResult)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_left_roi();
  inline void clear_has_left_roi();
  inline void set_has_right_roi();
  inline void clear_has_right_roi();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int left_;
  int right_;
  ::DMSOutputProtocol::Rect *left_roi_;
  ::DMSOutputProtocol::Rect *right_roi_;
  ::DMSOutputProtocol::EyeScore *score_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static EyeResult *default_instance_;
};
// -------------------------------------------------------------------

class SmokeResult : public ::google::protobuf::Message {
 public:
  SmokeResult();
  virtual ~SmokeResult();

  SmokeResult(const SmokeResult &from);

  inline SmokeResult &operator=(const SmokeResult &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const SmokeResult &default_instance();

  void Swap(SmokeResult *other);

  // implements Message ----------------------------------------------

  SmokeResult *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const SmokeResult &from);
  void MergeFrom(const SmokeResult &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.SmokeState smoke_state = 1;
  inline bool has_smoke_state() const;
  inline void clear_smoke_state();
  static const int kSmokeStateFieldNumber = 1;
  inline ::DMSOutputProtocol::SmokeState smoke_state() const;
  inline void set_smoke_state(::DMSOutputProtocol::SmokeState value);

  // required .DMSOutputProtocol.Rect smoke_roi = 2;
  inline bool has_smoke_roi() const;
  inline void clear_smoke_roi();
  static const int kSmokeRoiFieldNumber = 2;
  inline const ::DMSOutputProtocol::Rect &smoke_roi() const;
  inline ::DMSOutputProtocol::Rect *mutable_smoke_roi();
  inline ::DMSOutputProtocol::Rect *release_smoke_roi();
  inline void set_allocated_smoke_roi(::DMSOutputProtocol::Rect *smoke_roi);

  // optional .DMSOutputProtocol.SmokeScore score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline const ::DMSOutputProtocol::SmokeScore &score() const;
  inline ::DMSOutputProtocol::SmokeScore *mutable_score();
  inline ::DMSOutputProtocol::SmokeScore *release_score();
  inline void set_allocated_score(::DMSOutputProtocol::SmokeScore *score);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.SmokeResult)
 private:
  inline void set_has_smoke_state();
  inline void clear_has_smoke_state();
  inline void set_has_smoke_roi();
  inline void clear_has_smoke_roi();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DMSOutputProtocol::Rect *smoke_roi_;
  ::DMSOutputProtocol::SmokeScore *score_;
  int smoke_state_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static SmokeResult *default_instance_;
};
// -------------------------------------------------------------------

class FaceROI : public ::google::protobuf::Message {
 public:
  FaceROI();
  virtual ~FaceROI();

  FaceROI(const FaceROI &from);

  inline FaceROI &operator=(const FaceROI &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const FaceROI &default_instance();

  void Swap(FaceROI *other);

  // implements Message ----------------------------------------------

  FaceROI *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const FaceROI &from);
  void MergeFrom(const FaceROI &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.Rect face_roi = 1;
  inline bool has_face_roi() const;
  inline void clear_face_roi();
  static const int kFaceRoiFieldNumber = 1;
  inline const ::DMSOutputProtocol::Rect &face_roi() const;
  inline ::DMSOutputProtocol::Rect *mutable_face_roi();
  inline ::DMSOutputProtocol::Rect *release_face_roi();
  inline void set_allocated_face_roi(::DMSOutputProtocol::Rect *face_roi);

  // optional float conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline float conf() const;
  inline void set_conf(float value);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.FaceROI)
 private:
  inline void set_has_face_roi();
  inline void clear_has_face_roi();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DMSOutputProtocol::Rect *face_roi_;
  float conf_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static FaceROI *default_instance_;
};
// -------------------------------------------------------------------

class FaceInfo : public ::google::protobuf::Message {
 public:
  FaceInfo();
  virtual ~FaceInfo();

  FaceInfo(const FaceInfo &from);

  inline FaceInfo &operator=(const FaceInfo &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const FaceInfo &default_instance();

  void Swap(FaceInfo *other);

  // implements Message ----------------------------------------------

  FaceInfo *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const FaceInfo &from);
  void MergeFrom(const FaceInfo &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.PersonType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::DMSOutputProtocol::PersonType type() const;
  inline void set_type(::DMSOutputProtocol::PersonType value);

  // required .DMSOutputProtocol.FaceROI face_roi = 2;
  inline bool has_face_roi() const;
  inline void clear_face_roi();
  static const int kFaceRoiFieldNumber = 2;
  inline const ::DMSOutputProtocol::FaceROI &face_roi() const;
  inline ::DMSOutputProtocol::FaceROI *mutable_face_roi();
  inline ::DMSOutputProtocol::FaceROI *release_face_roi();
  inline void set_allocated_face_roi(::DMSOutputProtocol::FaceROI *face_roi);

  // optional .DMSOutputProtocol.LDMK ldmk = 3;
  inline bool has_ldmk() const;
  inline void clear_ldmk();
  static const int kLdmkFieldNumber = 3;
  inline const ::DMSOutputProtocol::LDMK &ldmk() const;
  inline ::DMSOutputProtocol::LDMK *mutable_ldmk();
  inline ::DMSOutputProtocol::LDMK *release_ldmk();
  inline void set_allocated_ldmk(::DMSOutputProtocol::LDMK *ldmk);

  // optional int32 tracking_id = 5;
  inline bool has_tracking_id() const;
  inline void clear_tracking_id();
  static const int kTrackingIdFieldNumber = 5;
  inline ::google::protobuf::int32 tracking_id() const;
  inline void set_tracking_id(::google::protobuf::int32 value);

  // optional .DMSOutputProtocol.FaceDirection face_direction = 10;
  inline bool has_face_direction() const;
  inline void clear_face_direction();
  static const int kFaceDirectionFieldNumber = 10;
  inline const ::DMSOutputProtocol::FaceDirection &face_direction() const;
  inline ::DMSOutputProtocol::FaceDirection *mutable_face_direction();
  inline ::DMSOutputProtocol::FaceDirection *release_face_direction();
  inline void set_allocated_face_direction(
      ::DMSOutputProtocol::FaceDirection *face_direction);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.FaceInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_face_roi();
  inline void clear_has_face_roi();
  inline void set_has_ldmk();
  inline void clear_has_ldmk();
  inline void set_has_tracking_id();
  inline void clear_has_tracking_id();
  inline void set_has_face_direction();
  inline void clear_has_face_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DMSOutputProtocol::FaceROI *face_roi_;
  int type_;
  ::google::protobuf::int32 tracking_id_;
  ::DMSOutputProtocol::LDMK *ldmk_;
  ::DMSOutputProtocol::FaceDirection *face_direction_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static FaceInfo *default_instance_;
};
// -------------------------------------------------------------------

class PersonInfo : public ::google::protobuf::Message {
 public:
  PersonInfo();
  virtual ~PersonInfo();

  PersonInfo(const PersonInfo &from);

  inline PersonInfo &operator=(const PersonInfo &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const PersonInfo &default_instance();

  void Swap(PersonInfo *other);

  // implements Message ----------------------------------------------

  PersonInfo *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const PersonInfo &from);
  void MergeFrom(const PersonInfo &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.FaceInfo face_info = 1;
  inline bool has_face_info() const;
  inline void clear_face_info();
  static const int kFaceInfoFieldNumber = 1;
  inline const ::DMSOutputProtocol::FaceInfo &face_info() const;
  inline ::DMSOutputProtocol::FaceInfo *mutable_face_info();
  inline ::DMSOutputProtocol::FaceInfo *release_face_info();
  inline void set_allocated_face_info(::DMSOutputProtocol::FaceInfo *face_info);

  // optional bytes face_feature = 2;
  inline bool has_face_feature() const;
  inline void clear_face_feature();
  static const int kFaceFeatureFieldNumber = 2;
  inline const ::std::string &face_feature() const;
  inline void set_face_feature(const ::std::string &value);
  inline void set_face_feature(const char *value);
  inline void set_face_feature(const void *value, size_t size);
  inline ::std::string *mutable_face_feature();
  inline ::std::string *release_face_feature();
  inline void set_allocated_face_feature(::std::string *face_feature);

  // optional .DMSOutputProtocol.EyeResult eye_result = 3;
  inline bool has_eye_result() const;
  inline void clear_eye_result();
  static const int kEyeResultFieldNumber = 3;
  inline const ::DMSOutputProtocol::EyeResult &eye_result() const;
  inline ::DMSOutputProtocol::EyeResult *mutable_eye_result();
  inline ::DMSOutputProtocol::EyeResult *release_eye_result();
  inline void set_allocated_eye_result(
      ::DMSOutputProtocol::EyeResult *eye_result);

  // optional .DMSOutputProtocol.SmokeResult smoke_result = 4;
  inline bool has_smoke_result() const;
  inline void clear_smoke_result();
  static const int kSmokeResultFieldNumber = 4;
  inline const ::DMSOutputProtocol::SmokeResult &smoke_result() const;
  inline ::DMSOutputProtocol::SmokeResult *mutable_smoke_result();
  inline ::DMSOutputProtocol::SmokeResult *release_smoke_result();
  inline void set_allocated_smoke_result(
      ::DMSOutputProtocol::SmokeResult *smoke_result);

  // repeated .DMSOutputProtocol.EventResult event_result = 6;
  inline int event_result_size() const;
  inline void clear_event_result();
  static const int kEventResultFieldNumber = 6;
  inline const ::DMSOutputProtocol::EventResult &event_result(int index) const;
  inline ::DMSOutputProtocol::EventResult *mutable_event_result(int index);
  inline ::DMSOutputProtocol::EventResult *add_event_result();
  inline const ::google::protobuf::RepeatedPtrField<
      ::DMSOutputProtocol::EventResult>
      &event_result() const;
  inline ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::EventResult>
      *mutable_event_result();

  // optional .DMSOutputProtocol.StateTrigger state_trigger = 7;
  inline bool has_state_trigger() const;
  inline void clear_state_trigger();
  static const int kStateTriggerFieldNumber = 7;
  inline const ::DMSOutputProtocol::StateTrigger &state_trigger() const;
  inline ::DMSOutputProtocol::StateTrigger *mutable_state_trigger();
  inline ::DMSOutputProtocol::StateTrigger *release_state_trigger();
  inline void set_allocated_state_trigger(
      ::DMSOutputProtocol::StateTrigger *state_trigger);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.PersonInfo)
 private:
  inline void set_has_face_info();
  inline void clear_has_face_info();
  inline void set_has_face_feature();
  inline void clear_has_face_feature();
  inline void set_has_eye_result();
  inline void clear_has_eye_result();
  inline void set_has_smoke_result();
  inline void clear_has_smoke_result();
  inline void set_has_state_trigger();
  inline void clear_has_state_trigger();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DMSOutputProtocol::FaceInfo *face_info_;
  ::std::string *face_feature_;
  ::DMSOutputProtocol::EyeResult *eye_result_;
  ::DMSOutputProtocol::SmokeResult *smoke_result_;
  ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::EventResult>
      event_result_;
  ::DMSOutputProtocol::StateTrigger *state_trigger_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static PersonInfo *default_instance_;
};
// -------------------------------------------------------------------

class VisionPercept : public ::google::protobuf::Message {
 public:
  VisionPercept();
  virtual ~VisionPercept();

  VisionPercept(const VisionPercept &from);

  inline VisionPercept &operator=(const VisionPercept &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const VisionPercept &default_instance();

  void Swap(VisionPercept *other);

  // implements Message ----------------------------------------------

  VisionPercept *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const VisionPercept &from);
  void MergeFrom(const VisionPercept &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DMSOutputProtocol.CameraType camera_type = 1;
  inline bool has_camera_type() const;
  inline void clear_camera_type();
  static const int kCameraTypeFieldNumber = 1;
  inline ::DMSOutputProtocol::CameraType camera_type() const;
  inline void set_camera_type(::DMSOutputProtocol::CameraType value);

  // required int32 frame_id = 2;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 2;
  inline ::google::protobuf::int32 frame_id() const;
  inline void set_frame_id(::google::protobuf::int32 value);

  // required sint64 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::int64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int64 value);

  // repeated .DMSOutputProtocol.PersonInfo person = 5;
  inline int person_size() const;
  inline void clear_person();
  static const int kPersonFieldNumber = 5;
  inline const ::DMSOutputProtocol::PersonInfo &person(int index) const;
  inline ::DMSOutputProtocol::PersonInfo *mutable_person(int index);
  inline ::DMSOutputProtocol::PersonInfo *add_person();
  inline const ::google::protobuf::RepeatedPtrField<
      ::DMSOutputProtocol::PersonInfo>
      &person() const;
  inline ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::PersonInfo>
      *mutable_person();

  // required .DMSOutputProtocol.DAAResult daa_result = 6;
  inline bool has_daa_result() const;
  inline void clear_daa_result();
  static const int kDaaResultFieldNumber = 6;
  inline const ::DMSOutputProtocol::DAAResult &daa_result() const;
  inline ::DMSOutputProtocol::DAAResult *mutable_daa_result();
  inline ::DMSOutputProtocol::DAAResult *release_daa_result();
  inline void set_allocated_daa_result(
      ::DMSOutputProtocol::DAAResult *daa_result);

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.VisionPercept)
 private:
  inline void set_has_camera_type();
  inline void clear_has_camera_type();
  inline void set_has_frame_id();
  inline void clear_has_frame_id();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_daa_result();
  inline void clear_has_daa_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int camera_type_;
  ::google::protobuf::int32 frame_id_;
  ::google::protobuf::int64 time_stamp_;
  ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::PersonInfo>
      person_;
  ::DMSOutputProtocol::DAAResult *daa_result_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static VisionPercept *default_instance_;
};
// -------------------------------------------------------------------

class PerceptResult : public ::google::protobuf::Message {
 public:
  PerceptResult();
  virtual ~PerceptResult();

  PerceptResult(const PerceptResult &from);

  inline PerceptResult &operator=(const PerceptResult &from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet &unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet *mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor *descriptor();
  static const PerceptResult &default_instance();

  void Swap(PerceptResult *other);

  // implements Message ----------------------------------------------

  PerceptResult *New() const;
  void CopyFrom(const ::google::protobuf::Message &from);
  void MergeFrom(const ::google::protobuf::Message &from);
  void CopyFrom(const PerceptResult &from);
  void MergeFrom(const PerceptResult &from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const;
  ::google::protobuf::uint8 *SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8 *output) const;
  int GetCachedSize() const { return _cached_size_; }

 private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

 public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DMSOutputProtocol.VisionPercept vision = 1;
  inline int vision_size() const;
  inline void clear_vision();
  static const int kVisionFieldNumber = 1;
  inline const ::DMSOutputProtocol::VisionPercept &vision(int index) const;
  inline ::DMSOutputProtocol::VisionPercept *mutable_vision(int index);
  inline ::DMSOutputProtocol::VisionPercept *add_vision();
  inline const ::google::protobuf::RepeatedPtrField<
      ::DMSOutputProtocol::VisionPercept>
      &vision() const;
  inline ::google::protobuf::RepeatedPtrField<
      ::DMSOutputProtocol::VisionPercept>
      *mutable_vision();

  // @@protoc_insertion_point(class_scope:DMSOutputProtocol.PerceptResult)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::VisionPercept>
      vision_;
  friend void protobuf_AddDesc_DMSSDKOutput_2eproto();
  friend void protobuf_AssignDesc_DMSSDKOutput_2eproto();
  friend void protobuf_ShutdownFile_DMSSDKOutput_2eproto();

  void InitAsDefaultInstance();
  static PerceptResult *default_instance_;
};
// ===================================================================


// ===================================================================

// Rect

// required int32 left = 1;
inline bool Rect::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_left() { _has_bits_[0] |= 0x00000001u; }
inline void Rect::clear_has_left() { _has_bits_[0] &= ~0x00000001u; }
inline void Rect::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 Rect::left() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Rect.left)
  return left_;
}
inline void Rect::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Rect.left)
}

// required int32 right = 2;
inline bool Rect::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_right() { _has_bits_[0] |= 0x00000002u; }
inline void Rect::clear_has_right() { _has_bits_[0] &= ~0x00000002u; }
inline void Rect::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 Rect::right() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Rect.right)
  return right_;
}
inline void Rect::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Rect.right)
}

// required int32 top = 3;
inline bool Rect::has_top() const { return (_has_bits_[0] & 0x00000004u) != 0; }
inline void Rect::set_has_top() { _has_bits_[0] |= 0x00000004u; }
inline void Rect::clear_has_top() { _has_bits_[0] &= ~0x00000004u; }
inline void Rect::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 Rect::top() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Rect.top)
  return top_;
}
inline void Rect::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Rect.top)
}

// required int32 bottom = 4;
inline bool Rect::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_bottom() { _has_bits_[0] |= 0x00000008u; }
inline void Rect::clear_has_bottom() { _has_bits_[0] &= ~0x00000008u; }
inline void Rect::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 Rect::bottom() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Rect.bottom)
  return bottom_;
}
inline void Rect::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Rect.bottom)
}

// -------------------------------------------------------------------

// Vector_3f

// required float x = 1;
inline bool Vector_3f::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector_3f::set_has_x() { _has_bits_[0] |= 0x00000001u; }
inline void Vector_3f::clear_has_x() { _has_bits_[0] &= ~0x00000001u; }
inline void Vector_3f::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector_3f::x() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Vector_3f.x)
  return x_;
}
inline void Vector_3f::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Vector_3f.x)
}

// required float y = 2;
inline bool Vector_3f::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector_3f::set_has_y() { _has_bits_[0] |= 0x00000002u; }
inline void Vector_3f::clear_has_y() { _has_bits_[0] &= ~0x00000002u; }
inline void Vector_3f::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector_3f::y() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Vector_3f.y)
  return y_;
}
inline void Vector_3f::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Vector_3f.y)
}

// required float z = 3;
inline bool Vector_3f::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector_3f::set_has_z() { _has_bits_[0] |= 0x00000004u; }
inline void Vector_3f::clear_has_z() { _has_bits_[0] &= ~0x00000004u; }
inline void Vector_3f::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector_3f::z() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Vector_3f.z)
  return z_;
}
inline void Vector_3f::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Vector_3f.z)
}

// -------------------------------------------------------------------

// Point

// required int32 x = 1;
inline bool Point::has_x() const { return (_has_bits_[0] & 0x00000001u) != 0; }
inline void Point::set_has_x() { _has_bits_[0] |= 0x00000001u; }
inline void Point::clear_has_x() { _has_bits_[0] &= ~0x00000001u; }
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Point::x() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Point.x)
  return x_;
}
inline void Point::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Point.x)
}

// required int32 y = 2;
inline bool Point::has_y() const { return (_has_bits_[0] & 0x00000002u) != 0; }
inline void Point::set_has_y() { _has_bits_[0] |= 0x00000002u; }
inline void Point::clear_has_y() { _has_bits_[0] &= ~0x00000002u; }
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Point::y() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.Point.y)
  return y_;
}
inline void Point::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.Point.y)
}

// -------------------------------------------------------------------

// StateTrigger

// required .DMSOutputProtocol.StateEnum ddw_l = 1;
inline bool StateTrigger::has_ddw_l() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateTrigger::set_has_ddw_l() { _has_bits_[0] |= 0x00000001u; }
inline void StateTrigger::clear_has_ddw_l() { _has_bits_[0] &= ~0x00000001u; }
inline void StateTrigger::clear_ddw_l() {
  ddw_l_ = 0;
  clear_has_ddw_l();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_l() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_l)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_l_);
}
inline void StateTrigger::set_ddw_l(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_l();
  ddw_l_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_l)
}

// required .DMSOutputProtocol.StateEnum ddw_r = 2;
inline bool StateTrigger::has_ddw_r() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateTrigger::set_has_ddw_r() { _has_bits_[0] |= 0x00000002u; }
inline void StateTrigger::clear_has_ddw_r() { _has_bits_[0] &= ~0x00000002u; }
inline void StateTrigger::clear_ddw_r() {
  ddw_r_ = 0;
  clear_has_ddw_r();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_r() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_r)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_r_);
}
inline void StateTrigger::set_ddw_r(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_r();
  ddw_r_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_r)
}

// required .DMSOutputProtocol.StateEnum ddw_u = 3;
inline bool StateTrigger::has_ddw_u() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateTrigger::set_has_ddw_u() { _has_bits_[0] |= 0x00000004u; }
inline void StateTrigger::clear_has_ddw_u() { _has_bits_[0] &= ~0x00000004u; }
inline void StateTrigger::clear_ddw_u() {
  ddw_u_ = 0;
  clear_has_ddw_u();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_u() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_u)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_u_);
}
inline void StateTrigger::set_ddw_u(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_u();
  ddw_u_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_u)
}

// required .DMSOutputProtocol.StateEnum ddw_d = 4;
inline bool StateTrigger::has_ddw_d() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StateTrigger::set_has_ddw_d() { _has_bits_[0] |= 0x00000008u; }
inline void StateTrigger::clear_has_ddw_d() { _has_bits_[0] &= ~0x00000008u; }
inline void StateTrigger::clear_ddw_d() {
  ddw_d_ = 0;
  clear_has_ddw_d();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_d() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_d)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_d_);
}
inline void StateTrigger::set_ddw_d(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_d();
  ddw_d_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_d)
}

// required .DMSOutputProtocol.StateEnum ddw_lu = 5;
inline bool StateTrigger::has_ddw_lu() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StateTrigger::set_has_ddw_lu() { _has_bits_[0] |= 0x00000010u; }
inline void StateTrigger::clear_has_ddw_lu() { _has_bits_[0] &= ~0x00000010u; }
inline void StateTrigger::clear_ddw_lu() {
  ddw_lu_ = 0;
  clear_has_ddw_lu();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_lu() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_lu)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_lu_);
}
inline void StateTrigger::set_ddw_lu(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_lu();
  ddw_lu_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_lu)
}

// required .DMSOutputProtocol.StateEnum ddw_ld = 6;
inline bool StateTrigger::has_ddw_ld() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StateTrigger::set_has_ddw_ld() { _has_bits_[0] |= 0x00000020u; }
inline void StateTrigger::clear_has_ddw_ld() { _has_bits_[0] &= ~0x00000020u; }
inline void StateTrigger::clear_ddw_ld() {
  ddw_ld_ = 0;
  clear_has_ddw_ld();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_ld() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_ld)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_ld_);
}
inline void StateTrigger::set_ddw_ld(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_ld();
  ddw_ld_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_ld)
}

// required .DMSOutputProtocol.StateEnum ddw_ru = 7;
inline bool StateTrigger::has_ddw_ru() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StateTrigger::set_has_ddw_ru() { _has_bits_[0] |= 0x00000040u; }
inline void StateTrigger::clear_has_ddw_ru() { _has_bits_[0] &= ~0x00000040u; }
inline void StateTrigger::clear_ddw_ru() {
  ddw_ru_ = 0;
  clear_has_ddw_ru();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_ru() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_ru)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_ru_);
}
inline void StateTrigger::set_ddw_ru(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_ru();
  ddw_ru_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_ru)
}

// required .DMSOutputProtocol.StateEnum ddw_rd = 8;
inline bool StateTrigger::has_ddw_rd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StateTrigger::set_has_ddw_rd() { _has_bits_[0] |= 0x00000080u; }
inline void StateTrigger::clear_has_ddw_rd() { _has_bits_[0] &= ~0x00000080u; }
inline void StateTrigger::clear_ddw_rd() {
  ddw_rd_ = 0;
  clear_has_ddw_rd();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::ddw_rd() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.ddw_rd)
  return static_cast< ::DMSOutputProtocol::StateEnum>(ddw_rd_);
}
inline void StateTrigger::set_ddw_rd(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_ddw_rd();
  ddw_rd_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.ddw_rd)
}

// required .DMSOutputProtocol.StateEnum dfw = 9;
inline bool StateTrigger::has_dfw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StateTrigger::set_has_dfw() { _has_bits_[0] |= 0x00000100u; }
inline void StateTrigger::clear_has_dfw() { _has_bits_[0] &= ~0x00000100u; }
inline void StateTrigger::clear_dfw() {
  dfw_ = 0;
  clear_has_dfw();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::dfw() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.dfw)
  return static_cast< ::DMSOutputProtocol::StateEnum>(dfw_);
}
inline void StateTrigger::set_dfw(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_dfw();
  dfw_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.dfw)
}

// required .DMSOutputProtocol.StateEnum dya = 10;
inline bool StateTrigger::has_dya() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StateTrigger::set_has_dya() { _has_bits_[0] |= 0x00000200u; }
inline void StateTrigger::clear_has_dya() { _has_bits_[0] &= ~0x00000200u; }
inline void StateTrigger::clear_dya() {
  dya_ = 0;
  clear_has_dya();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::dya() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.dya)
  return static_cast< ::DMSOutputProtocol::StateEnum>(dya_);
}
inline void StateTrigger::set_dya(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_dya();
  dya_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.dya)
}

// required .DMSOutputProtocol.StateEnum dca = 11;
inline bool StateTrigger::has_dca() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StateTrigger::set_has_dca() { _has_bits_[0] |= 0x00000400u; }
inline void StateTrigger::clear_has_dca() { _has_bits_[0] &= ~0x00000400u; }
inline void StateTrigger::clear_dca() {
  dca_ = 0;
  clear_has_dca();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::dca() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.dca)
  return static_cast< ::DMSOutputProtocol::StateEnum>(dca_);
}
inline void StateTrigger::set_dca(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_dca();
  dca_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.dca)
}

// required .DMSOutputProtocol.StateEnum dsa = 12;
inline bool StateTrigger::has_dsa() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StateTrigger::set_has_dsa() { _has_bits_[0] |= 0x00000800u; }
inline void StateTrigger::clear_has_dsa() { _has_bits_[0] &= ~0x00000800u; }
inline void StateTrigger::clear_dsa() {
  dsa_ = 0;
  clear_has_dsa();
}
inline ::DMSOutputProtocol::StateEnum StateTrigger::dsa() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateTrigger.dsa)
  return static_cast< ::DMSOutputProtocol::StateEnum>(dsa_);
}
inline void StateTrigger::set_dsa(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_dsa();
  dsa_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateTrigger.dsa)
}

// -------------------------------------------------------------------

// EyeScore

// required float left_open_score = 1;
inline bool EyeScore::has_left_open_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EyeScore::set_has_left_open_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EyeScore::clear_has_left_open_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EyeScore::clear_left_open_score() {
  left_open_score_ = 0;
  clear_has_left_open_score();
}
inline float EyeScore::left_open_score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeScore.left_open_score)
  return left_open_score_;
}
inline void EyeScore::set_left_open_score(float value) {
  set_has_left_open_score();
  left_open_score_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeScore.left_open_score)
}

// required float left_close_score = 2;
inline bool EyeScore::has_left_close_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EyeScore::set_has_left_close_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EyeScore::clear_has_left_close_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EyeScore::clear_left_close_score() {
  left_close_score_ = 0;
  clear_has_left_close_score();
}
inline float EyeScore::left_close_score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeScore.left_close_score)
  return left_close_score_;
}
inline void EyeScore::set_left_close_score(float value) {
  set_has_left_close_score();
  left_close_score_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeScore.left_close_score)
}

// required float left_unknow_score = 3;
inline bool EyeScore::has_left_unknow_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EyeScore::set_has_left_unknow_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EyeScore::clear_has_left_unknow_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EyeScore::clear_left_unknow_score() {
  left_unknow_score_ = 0;
  clear_has_left_unknow_score();
}
inline float EyeScore::left_unknow_score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeScore.left_unknow_score)
  return left_unknow_score_;
}
inline void EyeScore::set_left_unknow_score(float value) {
  set_has_left_unknow_score();
  left_unknow_score_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeScore.left_unknow_score)
}

// required float right_open_score = 4;
inline bool EyeScore::has_right_open_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EyeScore::set_has_right_open_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EyeScore::clear_has_right_open_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EyeScore::clear_right_open_score() {
  right_open_score_ = 0;
  clear_has_right_open_score();
}
inline float EyeScore::right_open_score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeScore.right_open_score)
  return right_open_score_;
}
inline void EyeScore::set_right_open_score(float value) {
  set_has_right_open_score();
  right_open_score_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeScore.right_open_score)
}

// required float right_close_score = 5;
inline bool EyeScore::has_right_close_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EyeScore::set_has_right_close_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EyeScore::clear_has_right_close_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EyeScore::clear_right_close_score() {
  right_close_score_ = 0;
  clear_has_right_close_score();
}
inline float EyeScore::right_close_score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeScore.right_close_score)
  return right_close_score_;
}
inline void EyeScore::set_right_close_score(float value) {
  set_has_right_close_score();
  right_close_score_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeScore.right_close_score)
}

// required float right_unknow_score = 6;
inline bool EyeScore::has_right_unknow_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EyeScore::set_has_right_unknow_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EyeScore::clear_has_right_unknow_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EyeScore::clear_right_unknow_score() {
  right_unknow_score_ = 0;
  clear_has_right_unknow_score();
}
inline float EyeScore::right_unknow_score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeScore.right_unknow_score)
  return right_unknow_score_;
}
inline void EyeScore::set_right_unknow_score(float value) {
  set_has_right_unknow_score();
  right_unknow_score_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeScore.right_unknow_score)
}

// -------------------------------------------------------------------

// SmokeScore

// required float no_smoke_normal = 1;
inline bool SmokeScore::has_no_smoke_normal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmokeScore::set_has_no_smoke_normal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmokeScore::clear_has_no_smoke_normal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmokeScore::clear_no_smoke_normal() {
  no_smoke_normal_ = 0;
  clear_has_no_smoke_normal();
}
inline float SmokeScore::no_smoke_normal() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.SmokeScore.no_smoke_normal)
  return no_smoke_normal_;
}
inline void SmokeScore::set_no_smoke_normal(float value) {
  set_has_no_smoke_normal();
  no_smoke_normal_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.SmokeScore.no_smoke_normal)
}

// required float smoke_normal = 2;
inline bool SmokeScore::has_smoke_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmokeScore::set_has_smoke_normal() { _has_bits_[0] |= 0x00000002u; }
inline void SmokeScore::clear_has_smoke_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmokeScore::clear_smoke_normal() {
  smoke_normal_ = 0;
  clear_has_smoke_normal();
}
inline float SmokeScore::smoke_normal() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.SmokeScore.smoke_normal)
  return smoke_normal_;
}
inline void SmokeScore::set_smoke_normal(float value) {
  set_has_smoke_normal();
  smoke_normal_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.SmokeScore.smoke_normal)
}

// required float no_smoke_suspect = 3;
inline bool SmokeScore::has_no_smoke_suspect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmokeScore::set_has_no_smoke_suspect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmokeScore::clear_has_no_smoke_suspect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmokeScore::clear_no_smoke_suspect() {
  no_smoke_suspect_ = 0;
  clear_has_no_smoke_suspect();
}
inline float SmokeScore::no_smoke_suspect() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.SmokeScore.no_smoke_suspect)
  return no_smoke_suspect_;
}
inline void SmokeScore::set_no_smoke_suspect(float value) {
  set_has_no_smoke_suspect();
  no_smoke_suspect_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.SmokeScore.no_smoke_suspect)
}

// -------------------------------------------------------------------

// RotRPY

// required float roll = 1;
inline bool RotRPY::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotRPY::set_has_roll() { _has_bits_[0] |= 0x00000001u; }
inline void RotRPY::clear_has_roll() { _has_bits_[0] &= ~0x00000001u; }
inline void RotRPY::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float RotRPY::roll() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.RotRPY.roll)
  return roll_;
}
inline void RotRPY::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.RotRPY.roll)
}

// required float pitch = 2;
inline bool RotRPY::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotRPY::set_has_pitch() { _has_bits_[0] |= 0x00000002u; }
inline void RotRPY::clear_has_pitch() { _has_bits_[0] &= ~0x00000002u; }
inline void RotRPY::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float RotRPY::pitch() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.RotRPY.pitch)
  return pitch_;
}
inline void RotRPY::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.RotRPY.pitch)
}

// required float yaw = 3;
inline bool RotRPY::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotRPY::set_has_yaw() { _has_bits_[0] |= 0x00000004u; }
inline void RotRPY::clear_has_yaw() { _has_bits_[0] &= ~0x00000004u; }
inline void RotRPY::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float RotRPY::yaw() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.RotRPY.yaw)
  return yaw_;
}
inline void RotRPY::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.RotRPY.yaw)
}

// -------------------------------------------------------------------

// RotVector

// required .DMSOutputProtocol.Vector_3f unit_vector = 1;
inline bool RotVector::has_unit_vector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotVector::set_has_unit_vector() { _has_bits_[0] |= 0x00000001u; }
inline void RotVector::clear_has_unit_vector() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotVector::clear_unit_vector() {
  if (unit_vector_ != NULL)
    unit_vector_->::DMSOutputProtocol::Vector_3f::Clear();
  clear_has_unit_vector();
}
inline const ::DMSOutputProtocol::Vector_3f &RotVector::unit_vector() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.RotVector.unit_vector)
  return unit_vector_ != NULL ? *unit_vector_
                              : *default_instance_->unit_vector_;
}
inline ::DMSOutputProtocol::Vector_3f *RotVector::mutable_unit_vector() {
  set_has_unit_vector();
  if (unit_vector_ == NULL)
    unit_vector_ = new ::DMSOutputProtocol::Vector_3f;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.RotVector.unit_vector)
  return unit_vector_;
}
inline ::DMSOutputProtocol::Vector_3f *RotVector::release_unit_vector() {
  clear_has_unit_vector();
  ::DMSOutputProtocol::Vector_3f *temp = unit_vector_;
  unit_vector_ = NULL;
  return temp;
}
inline void RotVector::set_allocated_unit_vector(
    ::DMSOutputProtocol::Vector_3f *unit_vector) {
  delete unit_vector_;
  unit_vector_ = unit_vector;
  if (unit_vector) {
    set_has_unit_vector();
  } else {
    clear_has_unit_vector();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.RotVector.unit_vector)
}

// -------------------------------------------------------------------

// FaceDirection

// required .DMSOutputProtocol.FaceDirEnum face_dir = 1;
inline bool FaceDirection::has_face_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaceDirection::set_has_face_dir() { _has_bits_[0] |= 0x00000001u; }
inline void FaceDirection::clear_has_face_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaceDirection::clear_face_dir() {
  face_dir_ = 0;
  clear_has_face_dir();
}
inline ::DMSOutputProtocol::FaceDirEnum FaceDirection::face_dir() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceDirection.face_dir)
  return static_cast< ::DMSOutputProtocol::FaceDirEnum>(face_dir_);
}
inline void FaceDirection::set_face_dir(
    ::DMSOutputProtocol::FaceDirEnum value) {
  assert(::DMSOutputProtocol::FaceDirEnum_IsValid(value));
  set_has_face_dir();
  face_dir_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.FaceDirection.face_dir)
}

// optional .DMSOutputProtocol.RotRPY cur_angle_rpy = 2;
inline bool FaceDirection::has_cur_angle_rpy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaceDirection::set_has_cur_angle_rpy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaceDirection::clear_has_cur_angle_rpy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaceDirection::clear_cur_angle_rpy() {
  if (cur_angle_rpy_ != NULL)
    cur_angle_rpy_->::DMSOutputProtocol::RotRPY::Clear();
  clear_has_cur_angle_rpy();
}
inline const ::DMSOutputProtocol::RotRPY &FaceDirection::cur_angle_rpy() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceDirection.cur_angle_rpy)
  return cur_angle_rpy_ != NULL ? *cur_angle_rpy_
                                : *default_instance_->cur_angle_rpy_;
}
inline ::DMSOutputProtocol::RotRPY *FaceDirection::mutable_cur_angle_rpy() {
  set_has_cur_angle_rpy();
  if (cur_angle_rpy_ == NULL)
    cur_angle_rpy_ = new ::DMSOutputProtocol::RotRPY;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceDirection.cur_angle_rpy)
  return cur_angle_rpy_;
}
inline ::DMSOutputProtocol::RotRPY *FaceDirection::release_cur_angle_rpy() {
  clear_has_cur_angle_rpy();
  ::DMSOutputProtocol::RotRPY *temp = cur_angle_rpy_;
  cur_angle_rpy_ = NULL;
  return temp;
}
inline void FaceDirection::set_allocated_cur_angle_rpy(
    ::DMSOutputProtocol::RotRPY *cur_angle_rpy) {
  delete cur_angle_rpy_;
  cur_angle_rpy_ = cur_angle_rpy;
  if (cur_angle_rpy) {
    set_has_cur_angle_rpy();
  } else {
    clear_has_cur_angle_rpy();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceDirection.cur_angle_rpy)
}

// optional .DMSOutputProtocol.RotRPY avr_angle_rpy = 3;
inline bool FaceDirection::has_avr_angle_rpy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaceDirection::set_has_avr_angle_rpy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FaceDirection::clear_has_avr_angle_rpy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FaceDirection::clear_avr_angle_rpy() {
  if (avr_angle_rpy_ != NULL)
    avr_angle_rpy_->::DMSOutputProtocol::RotRPY::Clear();
  clear_has_avr_angle_rpy();
}
inline const ::DMSOutputProtocol::RotRPY &FaceDirection::avr_angle_rpy() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceDirection.avr_angle_rpy)
  return avr_angle_rpy_ != NULL ? *avr_angle_rpy_
                                : *default_instance_->avr_angle_rpy_;
}
inline ::DMSOutputProtocol::RotRPY *FaceDirection::mutable_avr_angle_rpy() {
  set_has_avr_angle_rpy();
  if (avr_angle_rpy_ == NULL)
    avr_angle_rpy_ = new ::DMSOutputProtocol::RotRPY;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceDirection.avr_angle_rpy)
  return avr_angle_rpy_;
}
inline ::DMSOutputProtocol::RotRPY *FaceDirection::release_avr_angle_rpy() {
  clear_has_avr_angle_rpy();
  ::DMSOutputProtocol::RotRPY *temp = avr_angle_rpy_;
  avr_angle_rpy_ = NULL;
  return temp;
}
inline void FaceDirection::set_allocated_avr_angle_rpy(
    ::DMSOutputProtocol::RotRPY *avr_angle_rpy) {
  delete avr_angle_rpy_;
  avr_angle_rpy_ = avr_angle_rpy;
  if (avr_angle_rpy) {
    set_has_avr_angle_rpy();
  } else {
    clear_has_avr_angle_rpy();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceDirection.avr_angle_rpy)
}

// optional .DMSOutputProtocol.RotVector cur_angle_unit_vector = 4;
inline bool FaceDirection::has_cur_angle_unit_vector() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FaceDirection::set_has_cur_angle_unit_vector() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FaceDirection::clear_has_cur_angle_unit_vector() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FaceDirection::clear_cur_angle_unit_vector() {
  if (cur_angle_unit_vector_ != NULL)
    cur_angle_unit_vector_->::DMSOutputProtocol::RotVector::Clear();
  clear_has_cur_angle_unit_vector();
}
inline const ::DMSOutputProtocol::RotVector &
FaceDirection::cur_angle_unit_vector() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceDirection.cur_angle_unit_vector)
  return cur_angle_unit_vector_ != NULL
             ? *cur_angle_unit_vector_
             : *default_instance_->cur_angle_unit_vector_;
}
inline ::DMSOutputProtocol::RotVector *
FaceDirection::mutable_cur_angle_unit_vector() {
  set_has_cur_angle_unit_vector();
  if (cur_angle_unit_vector_ == NULL)
    cur_angle_unit_vector_ = new ::DMSOutputProtocol::RotVector;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceDirection.cur_angle_unit_vector)
  return cur_angle_unit_vector_;
}
inline ::DMSOutputProtocol::RotVector *
FaceDirection::release_cur_angle_unit_vector() {
  clear_has_cur_angle_unit_vector();
  ::DMSOutputProtocol::RotVector *temp = cur_angle_unit_vector_;
  cur_angle_unit_vector_ = NULL;
  return temp;
}
inline void FaceDirection::set_allocated_cur_angle_unit_vector(
    ::DMSOutputProtocol::RotVector *cur_angle_unit_vector) {
  delete cur_angle_unit_vector_;
  cur_angle_unit_vector_ = cur_angle_unit_vector;
  if (cur_angle_unit_vector) {
    set_has_cur_angle_unit_vector();
  } else {
    clear_has_cur_angle_unit_vector();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceDirection.cur_angle_unit_vector)
}

// optional .DMSOutputProtocol.RotVector avr_angle_unit_vector = 5;
inline bool FaceDirection::has_avr_angle_unit_vector() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FaceDirection::set_has_avr_angle_unit_vector() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FaceDirection::clear_has_avr_angle_unit_vector() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FaceDirection::clear_avr_angle_unit_vector() {
  if (avr_angle_unit_vector_ != NULL)
    avr_angle_unit_vector_->::DMSOutputProtocol::RotVector::Clear();
  clear_has_avr_angle_unit_vector();
}
inline const ::DMSOutputProtocol::RotVector &
FaceDirection::avr_angle_unit_vector() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceDirection.avr_angle_unit_vector)
  return avr_angle_unit_vector_ != NULL
             ? *avr_angle_unit_vector_
             : *default_instance_->avr_angle_unit_vector_;
}
inline ::DMSOutputProtocol::RotVector *
FaceDirection::mutable_avr_angle_unit_vector() {
  set_has_avr_angle_unit_vector();
  if (avr_angle_unit_vector_ == NULL)
    avr_angle_unit_vector_ = new ::DMSOutputProtocol::RotVector;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceDirection.avr_angle_unit_vector)
  return avr_angle_unit_vector_;
}
inline ::DMSOutputProtocol::RotVector *
FaceDirection::release_avr_angle_unit_vector() {
  clear_has_avr_angle_unit_vector();
  ::DMSOutputProtocol::RotVector *temp = avr_angle_unit_vector_;
  avr_angle_unit_vector_ = NULL;
  return temp;
}
inline void FaceDirection::set_allocated_avr_angle_unit_vector(
    ::DMSOutputProtocol::RotVector *avr_angle_unit_vector) {
  delete avr_angle_unit_vector_;
  avr_angle_unit_vector_ = avr_angle_unit_vector;
  if (avr_angle_unit_vector) {
    set_has_avr_angle_unit_vector();
  } else {
    clear_has_avr_angle_unit_vector();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceDirection.avr_angle_unit_vector)
}

// -------------------------------------------------------------------

// EventResult

// required .DMSOutputProtocol.EventEnum event = 1;
inline bool EventResult::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventResult::set_has_event() { _has_bits_[0] |= 0x00000001u; }
inline void EventResult::clear_has_event() { _has_bits_[0] &= ~0x00000001u; }
inline void EventResult::clear_event() {
  event_ = 0;
  clear_has_event();
}
inline ::DMSOutputProtocol::EventEnum EventResult::event() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EventResult.event)
  return static_cast< ::DMSOutputProtocol::EventEnum>(event_);
}
inline void EventResult::set_event(::DMSOutputProtocol::EventEnum value) {
  assert(::DMSOutputProtocol::EventEnum_IsValid(value));
  set_has_event();
  event_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EventResult.event)
}

// -------------------------------------------------------------------

// DAAResult

// required .DMSOutputProtocol.EventEnum daa_event = 1;
inline bool DAAResult::has_daa_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DAAResult::set_has_daa_event() { _has_bits_[0] |= 0x00000001u; }
inline void DAAResult::clear_has_daa_event() { _has_bits_[0] &= ~0x00000001u; }
inline void DAAResult::clear_daa_event() {
  daa_event_ = 0;
  clear_has_daa_event();
}
inline ::DMSOutputProtocol::EventEnum DAAResult::daa_event() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.DAAResult.daa_event)
  return static_cast< ::DMSOutputProtocol::EventEnum>(daa_event_);
}
inline void DAAResult::set_daa_event(::DMSOutputProtocol::EventEnum value) {
  assert(::DMSOutputProtocol::EventEnum_IsValid(value));
  set_has_daa_event();
  daa_event_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.DAAResult.daa_event)
}

// -------------------------------------------------------------------

// StateResult

// required .DMSOutputProtocol.StateEnum state = 1;
inline bool StateResult::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateResult::set_has_state() { _has_bits_[0] |= 0x00000001u; }
inline void StateResult::clear_has_state() { _has_bits_[0] &= ~0x00000001u; }
inline void StateResult::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::DMSOutputProtocol::StateEnum StateResult::state() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.StateResult.state)
  return static_cast< ::DMSOutputProtocol::StateEnum>(state_);
}
inline void StateResult::set_state(::DMSOutputProtocol::StateEnum value) {
  assert(::DMSOutputProtocol::StateEnum_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.StateResult.state)
}

// -------------------------------------------------------------------

// LDMK

// repeated .DMSOutputProtocol.Point face_feature_points = 1;
inline int LDMK::face_feature_points_size() const {
  return face_feature_points_.size();
}
inline void LDMK::clear_face_feature_points() { face_feature_points_.Clear(); }
inline const ::DMSOutputProtocol::Point &LDMK::face_feature_points(
    int index) const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.LDMK.face_feature_points)
  return face_feature_points_.Get(index);
}
inline ::DMSOutputProtocol::Point *LDMK::mutable_face_feature_points(
    int index) {
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.LDMK.face_feature_points)
  return face_feature_points_.Mutable(index);
}
inline ::DMSOutputProtocol::Point *LDMK::add_face_feature_points() {
  // @@protoc_insertion_point(field_add:DMSOutputProtocol.LDMK.face_feature_points)
  return face_feature_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::Point>
    &LDMK::face_feature_points() const {
  // @@protoc_insertion_point(field_list:DMSOutputProtocol.LDMK.face_feature_points)
  return face_feature_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::Point>
    *LDMK::mutable_face_feature_points() {
  // @@protoc_insertion_point(field_mutable_list:DMSOutputProtocol.LDMK.face_feature_points)
  return &face_feature_points_;
}

// -------------------------------------------------------------------

// EyeResult

// required .DMSOutputProtocol.EyeState left = 1;
inline bool EyeResult::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EyeResult::set_has_left() { _has_bits_[0] |= 0x00000001u; }
inline void EyeResult::clear_has_left() { _has_bits_[0] &= ~0x00000001u; }
inline void EyeResult::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::DMSOutputProtocol::EyeState EyeResult::left() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeResult.left)
  return static_cast< ::DMSOutputProtocol::EyeState>(left_);
}
inline void EyeResult::set_left(::DMSOutputProtocol::EyeState value) {
  assert(::DMSOutputProtocol::EyeState_IsValid(value));
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeResult.left)
}

// required .DMSOutputProtocol.EyeState right = 2;
inline bool EyeResult::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EyeResult::set_has_right() { _has_bits_[0] |= 0x00000002u; }
inline void EyeResult::clear_has_right() { _has_bits_[0] &= ~0x00000002u; }
inline void EyeResult::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::DMSOutputProtocol::EyeState EyeResult::right() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeResult.right)
  return static_cast< ::DMSOutputProtocol::EyeState>(right_);
}
inline void EyeResult::set_right(::DMSOutputProtocol::EyeState value) {
  assert(::DMSOutputProtocol::EyeState_IsValid(value));
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.EyeResult.right)
}

// required .DMSOutputProtocol.Rect left_roi = 3;
inline bool EyeResult::has_left_roi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EyeResult::set_has_left_roi() { _has_bits_[0] |= 0x00000004u; }
inline void EyeResult::clear_has_left_roi() { _has_bits_[0] &= ~0x00000004u; }
inline void EyeResult::clear_left_roi() {
  if (left_roi_ != NULL)
    left_roi_->::DMSOutputProtocol::Rect::Clear();
  clear_has_left_roi();
}
inline const ::DMSOutputProtocol::Rect &EyeResult::left_roi() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeResult.left_roi)
  return left_roi_ != NULL ? *left_roi_ : *default_instance_->left_roi_;
}
inline ::DMSOutputProtocol::Rect *EyeResult::mutable_left_roi() {
  set_has_left_roi();
  if (left_roi_ == NULL)
    left_roi_ = new ::DMSOutputProtocol::Rect;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.EyeResult.left_roi)
  return left_roi_;
}
inline ::DMSOutputProtocol::Rect *EyeResult::release_left_roi() {
  clear_has_left_roi();
  ::DMSOutputProtocol::Rect *temp = left_roi_;
  left_roi_ = NULL;
  return temp;
}
inline void EyeResult::set_allocated_left_roi(
    ::DMSOutputProtocol::Rect *left_roi) {
  delete left_roi_;
  left_roi_ = left_roi;
  if (left_roi) {
    set_has_left_roi();
  } else {
    clear_has_left_roi();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.EyeResult.left_roi)
}

// required .DMSOutputProtocol.Rect right_roi = 4;
inline bool EyeResult::has_right_roi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EyeResult::set_has_right_roi() { _has_bits_[0] |= 0x00000008u; }
inline void EyeResult::clear_has_right_roi() { _has_bits_[0] &= ~0x00000008u; }
inline void EyeResult::clear_right_roi() {
  if (right_roi_ != NULL)
    right_roi_->::DMSOutputProtocol::Rect::Clear();
  clear_has_right_roi();
}
inline const ::DMSOutputProtocol::Rect &EyeResult::right_roi() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeResult.right_roi)
  return right_roi_ != NULL ? *right_roi_ : *default_instance_->right_roi_;
}
inline ::DMSOutputProtocol::Rect *EyeResult::mutable_right_roi() {
  set_has_right_roi();
  if (right_roi_ == NULL)
    right_roi_ = new ::DMSOutputProtocol::Rect;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.EyeResult.right_roi)
  return right_roi_;
}
inline ::DMSOutputProtocol::Rect *EyeResult::release_right_roi() {
  clear_has_right_roi();
  ::DMSOutputProtocol::Rect *temp = right_roi_;
  right_roi_ = NULL;
  return temp;
}
inline void EyeResult::set_allocated_right_roi(
    ::DMSOutputProtocol::Rect *right_roi) {
  delete right_roi_;
  right_roi_ = right_roi;
  if (right_roi) {
    set_has_right_roi();
  } else {
    clear_has_right_roi();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.EyeResult.right_roi)
}

// optional .DMSOutputProtocol.EyeScore score = 5;
inline bool EyeResult::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EyeResult::set_has_score() { _has_bits_[0] |= 0x00000010u; }
inline void EyeResult::clear_has_score() { _has_bits_[0] &= ~0x00000010u; }
inline void EyeResult::clear_score() {
  if (score_ != NULL)
    score_->::DMSOutputProtocol::EyeScore::Clear();
  clear_has_score();
}
inline const ::DMSOutputProtocol::EyeScore &EyeResult::score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.EyeResult.score)
  return score_ != NULL ? *score_ : *default_instance_->score_;
}
inline ::DMSOutputProtocol::EyeScore *EyeResult::mutable_score() {
  set_has_score();
  if (score_ == NULL)
    score_ = new ::DMSOutputProtocol::EyeScore;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.EyeResult.score)
  return score_;
}
inline ::DMSOutputProtocol::EyeScore *EyeResult::release_score() {
  clear_has_score();
  ::DMSOutputProtocol::EyeScore *temp = score_;
  score_ = NULL;
  return temp;
}
inline void EyeResult::set_allocated_score(
    ::DMSOutputProtocol::EyeScore *score) {
  delete score_;
  score_ = score;
  if (score) {
    set_has_score();
  } else {
    clear_has_score();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.EyeResult.score)
}

// -------------------------------------------------------------------

// SmokeResult

// required .DMSOutputProtocol.SmokeState smoke_state = 1;
inline bool SmokeResult::has_smoke_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmokeResult::set_has_smoke_state() { _has_bits_[0] |= 0x00000001u; }
inline void SmokeResult::clear_has_smoke_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmokeResult::clear_smoke_state() {
  smoke_state_ = 0;
  clear_has_smoke_state();
}
inline ::DMSOutputProtocol::SmokeState SmokeResult::smoke_state() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.SmokeResult.smoke_state)
  return static_cast< ::DMSOutputProtocol::SmokeState>(smoke_state_);
}
inline void SmokeResult::set_smoke_state(
    ::DMSOutputProtocol::SmokeState value) {
  assert(::DMSOutputProtocol::SmokeState_IsValid(value));
  set_has_smoke_state();
  smoke_state_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.SmokeResult.smoke_state)
}

// required .DMSOutputProtocol.Rect smoke_roi = 2;
inline bool SmokeResult::has_smoke_roi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmokeResult::set_has_smoke_roi() { _has_bits_[0] |= 0x00000002u; }
inline void SmokeResult::clear_has_smoke_roi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmokeResult::clear_smoke_roi() {
  if (smoke_roi_ != NULL)
    smoke_roi_->::DMSOutputProtocol::Rect::Clear();
  clear_has_smoke_roi();
}
inline const ::DMSOutputProtocol::Rect &SmokeResult::smoke_roi() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.SmokeResult.smoke_roi)
  return smoke_roi_ != NULL ? *smoke_roi_ : *default_instance_->smoke_roi_;
}
inline ::DMSOutputProtocol::Rect *SmokeResult::mutable_smoke_roi() {
  set_has_smoke_roi();
  if (smoke_roi_ == NULL)
    smoke_roi_ = new ::DMSOutputProtocol::Rect;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.SmokeResult.smoke_roi)
  return smoke_roi_;
}
inline ::DMSOutputProtocol::Rect *SmokeResult::release_smoke_roi() {
  clear_has_smoke_roi();
  ::DMSOutputProtocol::Rect *temp = smoke_roi_;
  smoke_roi_ = NULL;
  return temp;
}
inline void SmokeResult::set_allocated_smoke_roi(
    ::DMSOutputProtocol::Rect *smoke_roi) {
  delete smoke_roi_;
  smoke_roi_ = smoke_roi;
  if (smoke_roi) {
    set_has_smoke_roi();
  } else {
    clear_has_smoke_roi();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.SmokeResult.smoke_roi)
}

// optional .DMSOutputProtocol.SmokeScore score = 3;
inline bool SmokeResult::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmokeResult::set_has_score() { _has_bits_[0] |= 0x00000004u; }
inline void SmokeResult::clear_has_score() { _has_bits_[0] &= ~0x00000004u; }
inline void SmokeResult::clear_score() {
  if (score_ != NULL)
    score_->::DMSOutputProtocol::SmokeScore::Clear();
  clear_has_score();
}
inline const ::DMSOutputProtocol::SmokeScore &SmokeResult::score() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.SmokeResult.score)
  return score_ != NULL ? *score_ : *default_instance_->score_;
}
inline ::DMSOutputProtocol::SmokeScore *SmokeResult::mutable_score() {
  set_has_score();
  if (score_ == NULL)
    score_ = new ::DMSOutputProtocol::SmokeScore;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.SmokeResult.score)
  return score_;
}
inline ::DMSOutputProtocol::SmokeScore *SmokeResult::release_score() {
  clear_has_score();
  ::DMSOutputProtocol::SmokeScore *temp = score_;
  score_ = NULL;
  return temp;
}
inline void SmokeResult::set_allocated_score(
    ::DMSOutputProtocol::SmokeScore *score) {
  delete score_;
  score_ = score;
  if (score) {
    set_has_score();
  } else {
    clear_has_score();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.SmokeResult.score)
}

// -------------------------------------------------------------------

// FaceROI

// required .DMSOutputProtocol.Rect face_roi = 1;
inline bool FaceROI::has_face_roi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaceROI::set_has_face_roi() { _has_bits_[0] |= 0x00000001u; }
inline void FaceROI::clear_has_face_roi() { _has_bits_[0] &= ~0x00000001u; }
inline void FaceROI::clear_face_roi() {
  if (face_roi_ != NULL)
    face_roi_->::DMSOutputProtocol::Rect::Clear();
  clear_has_face_roi();
}
inline const ::DMSOutputProtocol::Rect &FaceROI::face_roi() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceROI.face_roi)
  return face_roi_ != NULL ? *face_roi_ : *default_instance_->face_roi_;
}
inline ::DMSOutputProtocol::Rect *FaceROI::mutable_face_roi() {
  set_has_face_roi();
  if (face_roi_ == NULL)
    face_roi_ = new ::DMSOutputProtocol::Rect;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceROI.face_roi)
  return face_roi_;
}
inline ::DMSOutputProtocol::Rect *FaceROI::release_face_roi() {
  clear_has_face_roi();
  ::DMSOutputProtocol::Rect *temp = face_roi_;
  face_roi_ = NULL;
  return temp;
}
inline void FaceROI::set_allocated_face_roi(
    ::DMSOutputProtocol::Rect *face_roi) {
  delete face_roi_;
  face_roi_ = face_roi;
  if (face_roi) {
    set_has_face_roi();
  } else {
    clear_has_face_roi();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceROI.face_roi)
}

// optional float conf = 2;
inline bool FaceROI::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaceROI::set_has_conf() { _has_bits_[0] |= 0x00000002u; }
inline void FaceROI::clear_has_conf() { _has_bits_[0] &= ~0x00000002u; }
inline void FaceROI::clear_conf() {
  conf_ = 0;
  clear_has_conf();
}
inline float FaceROI::conf() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceROI.conf)
  return conf_;
}
inline void FaceROI::set_conf(float value) {
  set_has_conf();
  conf_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.FaceROI.conf)
}

// -------------------------------------------------------------------

// FaceInfo

// required .DMSOutputProtocol.PersonType type = 1;
inline bool FaceInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaceInfo::set_has_type() { _has_bits_[0] |= 0x00000001u; }
inline void FaceInfo::clear_has_type() { _has_bits_[0] &= ~0x00000001u; }
inline void FaceInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::DMSOutputProtocol::PersonType FaceInfo::type() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceInfo.type)
  return static_cast< ::DMSOutputProtocol::PersonType>(type_);
}
inline void FaceInfo::set_type(::DMSOutputProtocol::PersonType value) {
  assert(::DMSOutputProtocol::PersonType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.FaceInfo.type)
}

// required .DMSOutputProtocol.FaceROI face_roi = 2;
inline bool FaceInfo::has_face_roi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaceInfo::set_has_face_roi() { _has_bits_[0] |= 0x00000002u; }
inline void FaceInfo::clear_has_face_roi() { _has_bits_[0] &= ~0x00000002u; }
inline void FaceInfo::clear_face_roi() {
  if (face_roi_ != NULL)
    face_roi_->::DMSOutputProtocol::FaceROI::Clear();
  clear_has_face_roi();
}
inline const ::DMSOutputProtocol::FaceROI &FaceInfo::face_roi() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceInfo.face_roi)
  return face_roi_ != NULL ? *face_roi_ : *default_instance_->face_roi_;
}
inline ::DMSOutputProtocol::FaceROI *FaceInfo::mutable_face_roi() {
  set_has_face_roi();
  if (face_roi_ == NULL)
    face_roi_ = new ::DMSOutputProtocol::FaceROI;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceInfo.face_roi)
  return face_roi_;
}
inline ::DMSOutputProtocol::FaceROI *FaceInfo::release_face_roi() {
  clear_has_face_roi();
  ::DMSOutputProtocol::FaceROI *temp = face_roi_;
  face_roi_ = NULL;
  return temp;
}
inline void FaceInfo::set_allocated_face_roi(
    ::DMSOutputProtocol::FaceROI *face_roi) {
  delete face_roi_;
  face_roi_ = face_roi;
  if (face_roi) {
    set_has_face_roi();
  } else {
    clear_has_face_roi();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceInfo.face_roi)
}

// optional .DMSOutputProtocol.LDMK ldmk = 3;
inline bool FaceInfo::has_ldmk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaceInfo::set_has_ldmk() { _has_bits_[0] |= 0x00000004u; }
inline void FaceInfo::clear_has_ldmk() { _has_bits_[0] &= ~0x00000004u; }
inline void FaceInfo::clear_ldmk() {
  if (ldmk_ != NULL)
    ldmk_->::DMSOutputProtocol::LDMK::Clear();
  clear_has_ldmk();
}
inline const ::DMSOutputProtocol::LDMK &FaceInfo::ldmk() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceInfo.ldmk)
  return ldmk_ != NULL ? *ldmk_ : *default_instance_->ldmk_;
}
inline ::DMSOutputProtocol::LDMK *FaceInfo::mutable_ldmk() {
  set_has_ldmk();
  if (ldmk_ == NULL)
    ldmk_ = new ::DMSOutputProtocol::LDMK;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceInfo.ldmk)
  return ldmk_;
}
inline ::DMSOutputProtocol::LDMK *FaceInfo::release_ldmk() {
  clear_has_ldmk();
  ::DMSOutputProtocol::LDMK *temp = ldmk_;
  ldmk_ = NULL;
  return temp;
}
inline void FaceInfo::set_allocated_ldmk(::DMSOutputProtocol::LDMK *ldmk) {
  delete ldmk_;
  ldmk_ = ldmk;
  if (ldmk) {
    set_has_ldmk();
  } else {
    clear_has_ldmk();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceInfo.ldmk)
}

// optional int32 tracking_id = 5;
inline bool FaceInfo::has_tracking_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FaceInfo::set_has_tracking_id() { _has_bits_[0] |= 0x00000008u; }
inline void FaceInfo::clear_has_tracking_id() { _has_bits_[0] &= ~0x00000008u; }
inline void FaceInfo::clear_tracking_id() {
  tracking_id_ = 0;
  clear_has_tracking_id();
}
inline ::google::protobuf::int32 FaceInfo::tracking_id() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceInfo.tracking_id)
  return tracking_id_;
}
inline void FaceInfo::set_tracking_id(::google::protobuf::int32 value) {
  set_has_tracking_id();
  tracking_id_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.FaceInfo.tracking_id)
}

// optional .DMSOutputProtocol.FaceDirection face_direction = 10;
inline bool FaceInfo::has_face_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FaceInfo::set_has_face_direction() { _has_bits_[0] |= 0x00000010u; }
inline void FaceInfo::clear_has_face_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FaceInfo::clear_face_direction() {
  if (face_direction_ != NULL)
    face_direction_->::DMSOutputProtocol::FaceDirection::Clear();
  clear_has_face_direction();
}
inline const ::DMSOutputProtocol::FaceDirection &FaceInfo::face_direction()
    const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.FaceInfo.face_direction)
  return face_direction_ != NULL ? *face_direction_
                                 : *default_instance_->face_direction_;
}
inline ::DMSOutputProtocol::FaceDirection *FaceInfo::mutable_face_direction() {
  set_has_face_direction();
  if (face_direction_ == NULL)
    face_direction_ = new ::DMSOutputProtocol::FaceDirection;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.FaceInfo.face_direction)
  return face_direction_;
}
inline ::DMSOutputProtocol::FaceDirection *FaceInfo::release_face_direction() {
  clear_has_face_direction();
  ::DMSOutputProtocol::FaceDirection *temp = face_direction_;
  face_direction_ = NULL;
  return temp;
}
inline void FaceInfo::set_allocated_face_direction(
    ::DMSOutputProtocol::FaceDirection *face_direction) {
  delete face_direction_;
  face_direction_ = face_direction;
  if (face_direction) {
    set_has_face_direction();
  } else {
    clear_has_face_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.FaceInfo.face_direction)
}

// -------------------------------------------------------------------

// PersonInfo

// required .DMSOutputProtocol.FaceInfo face_info = 1;
inline bool PersonInfo::has_face_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PersonInfo::set_has_face_info() { _has_bits_[0] |= 0x00000001u; }
inline void PersonInfo::clear_has_face_info() { _has_bits_[0] &= ~0x00000001u; }
inline void PersonInfo::clear_face_info() {
  if (face_info_ != NULL)
    face_info_->::DMSOutputProtocol::FaceInfo::Clear();
  clear_has_face_info();
}
inline const ::DMSOutputProtocol::FaceInfo &PersonInfo::face_info() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.PersonInfo.face_info)
  return face_info_ != NULL ? *face_info_ : *default_instance_->face_info_;
}
inline ::DMSOutputProtocol::FaceInfo *PersonInfo::mutable_face_info() {
  set_has_face_info();
  if (face_info_ == NULL)
    face_info_ = new ::DMSOutputProtocol::FaceInfo;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.PersonInfo.face_info)
  return face_info_;
}
inline ::DMSOutputProtocol::FaceInfo *PersonInfo::release_face_info() {
  clear_has_face_info();
  ::DMSOutputProtocol::FaceInfo *temp = face_info_;
  face_info_ = NULL;
  return temp;
}
inline void PersonInfo::set_allocated_face_info(
    ::DMSOutputProtocol::FaceInfo *face_info) {
  delete face_info_;
  face_info_ = face_info;
  if (face_info) {
    set_has_face_info();
  } else {
    clear_has_face_info();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.PersonInfo.face_info)
}

// optional bytes face_feature = 2;
inline bool PersonInfo::has_face_feature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PersonInfo::set_has_face_feature() { _has_bits_[0] |= 0x00000002u; }
inline void PersonInfo::clear_has_face_feature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PersonInfo::clear_face_feature() {
  if (face_feature_ !=
      &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_feature_->clear();
  }
  clear_has_face_feature();
}
inline const ::std::string &PersonInfo::face_feature() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.PersonInfo.face_feature)
  return *face_feature_;
}
inline void PersonInfo::set_face_feature(const ::std::string &value) {
  set_has_face_feature();
  if (face_feature_ ==
      &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_feature_ = new ::std::string;
  }
  face_feature_->assign(value);
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.PersonInfo.face_feature)
}
inline void PersonInfo::set_face_feature(const char *value) {
  set_has_face_feature();
  if (face_feature_ ==
      &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_feature_ = new ::std::string;
  }
  face_feature_->assign(value);
  // @@protoc_insertion_point(field_set_char:DMSOutputProtocol.PersonInfo.face_feature)
}
inline void PersonInfo::set_face_feature(const void *value, size_t size) {
  set_has_face_feature();
  if (face_feature_ ==
      &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_feature_ = new ::std::string;
  }
  face_feature_->assign(reinterpret_cast<const char *>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DMSOutputProtocol.PersonInfo.face_feature)
}
inline ::std::string *PersonInfo::mutable_face_feature() {
  set_has_face_feature();
  if (face_feature_ ==
      &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    face_feature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.PersonInfo.face_feature)
  return face_feature_;
}
inline ::std::string *PersonInfo::release_face_feature() {
  clear_has_face_feature();
  if (face_feature_ ==
      &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string *temp = face_feature_;
    face_feature_ = const_cast< ::std::string *>(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PersonInfo::set_allocated_face_feature(
    ::std::string *face_feature) {
  if (face_feature_ !=
      &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete face_feature_;
  }
  if (face_feature) {
    set_has_face_feature();
    face_feature_ = face_feature;
  } else {
    clear_has_face_feature();
    face_feature_ = const_cast< ::std::string *>(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.PersonInfo.face_feature)
}

// optional .DMSOutputProtocol.EyeResult eye_result = 3;
inline bool PersonInfo::has_eye_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PersonInfo::set_has_eye_result() { _has_bits_[0] |= 0x00000004u; }
inline void PersonInfo::clear_has_eye_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PersonInfo::clear_eye_result() {
  if (eye_result_ != NULL)
    eye_result_->::DMSOutputProtocol::EyeResult::Clear();
  clear_has_eye_result();
}
inline const ::DMSOutputProtocol::EyeResult &PersonInfo::eye_result() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.PersonInfo.eye_result)
  return eye_result_ != NULL ? *eye_result_ : *default_instance_->eye_result_;
}
inline ::DMSOutputProtocol::EyeResult *PersonInfo::mutable_eye_result() {
  set_has_eye_result();
  if (eye_result_ == NULL)
    eye_result_ = new ::DMSOutputProtocol::EyeResult;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.PersonInfo.eye_result)
  return eye_result_;
}
inline ::DMSOutputProtocol::EyeResult *PersonInfo::release_eye_result() {
  clear_has_eye_result();
  ::DMSOutputProtocol::EyeResult *temp = eye_result_;
  eye_result_ = NULL;
  return temp;
}
inline void PersonInfo::set_allocated_eye_result(
    ::DMSOutputProtocol::EyeResult *eye_result) {
  delete eye_result_;
  eye_result_ = eye_result;
  if (eye_result) {
    set_has_eye_result();
  } else {
    clear_has_eye_result();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.PersonInfo.eye_result)
}

// optional .DMSOutputProtocol.SmokeResult smoke_result = 4;
inline bool PersonInfo::has_smoke_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PersonInfo::set_has_smoke_result() { _has_bits_[0] |= 0x00000008u; }
inline void PersonInfo::clear_has_smoke_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PersonInfo::clear_smoke_result() {
  if (smoke_result_ != NULL)
    smoke_result_->::DMSOutputProtocol::SmokeResult::Clear();
  clear_has_smoke_result();
}
inline const ::DMSOutputProtocol::SmokeResult &PersonInfo::smoke_result()
    const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.PersonInfo.smoke_result)
  return smoke_result_ != NULL ? *smoke_result_
                               : *default_instance_->smoke_result_;
}
inline ::DMSOutputProtocol::SmokeResult *PersonInfo::mutable_smoke_result() {
  set_has_smoke_result();
  if (smoke_result_ == NULL)
    smoke_result_ = new ::DMSOutputProtocol::SmokeResult;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.PersonInfo.smoke_result)
  return smoke_result_;
}
inline ::DMSOutputProtocol::SmokeResult *PersonInfo::release_smoke_result() {
  clear_has_smoke_result();
  ::DMSOutputProtocol::SmokeResult *temp = smoke_result_;
  smoke_result_ = NULL;
  return temp;
}
inline void PersonInfo::set_allocated_smoke_result(
    ::DMSOutputProtocol::SmokeResult *smoke_result) {
  delete smoke_result_;
  smoke_result_ = smoke_result;
  if (smoke_result) {
    set_has_smoke_result();
  } else {
    clear_has_smoke_result();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.PersonInfo.smoke_result)
}

// repeated .DMSOutputProtocol.EventResult event_result = 6;
inline int PersonInfo::event_result_size() const {
  return event_result_.size();
}
inline void PersonInfo::clear_event_result() { event_result_.Clear(); }
inline const ::DMSOutputProtocol::EventResult &PersonInfo::event_result(
    int index) const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.PersonInfo.event_result)
  return event_result_.Get(index);
}
inline ::DMSOutputProtocol::EventResult *PersonInfo::mutable_event_result(
    int index) {
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.PersonInfo.event_result)
  return event_result_.Mutable(index);
}
inline ::DMSOutputProtocol::EventResult *PersonInfo::add_event_result() {
  // @@protoc_insertion_point(field_add:DMSOutputProtocol.PersonInfo.event_result)
  return event_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<
    ::DMSOutputProtocol::EventResult>
    &PersonInfo::event_result() const {
  // @@protoc_insertion_point(field_list:DMSOutputProtocol.PersonInfo.event_result)
  return event_result_;
}
inline ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::EventResult>
    *PersonInfo::mutable_event_result() {
  // @@protoc_insertion_point(field_mutable_list:DMSOutputProtocol.PersonInfo.event_result)
  return &event_result_;
}

// optional .DMSOutputProtocol.StateTrigger state_trigger = 7;
inline bool PersonInfo::has_state_trigger() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PersonInfo::set_has_state_trigger() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PersonInfo::clear_has_state_trigger() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PersonInfo::clear_state_trigger() {
  if (state_trigger_ != NULL)
    state_trigger_->::DMSOutputProtocol::StateTrigger::Clear();
  clear_has_state_trigger();
}
inline const ::DMSOutputProtocol::StateTrigger &PersonInfo::state_trigger()
    const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.PersonInfo.state_trigger)
  return state_trigger_ != NULL ? *state_trigger_
                                : *default_instance_->state_trigger_;
}
inline ::DMSOutputProtocol::StateTrigger *PersonInfo::mutable_state_trigger() {
  set_has_state_trigger();
  if (state_trigger_ == NULL)
    state_trigger_ = new ::DMSOutputProtocol::StateTrigger;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.PersonInfo.state_trigger)
  return state_trigger_;
}
inline ::DMSOutputProtocol::StateTrigger *PersonInfo::release_state_trigger() {
  clear_has_state_trigger();
  ::DMSOutputProtocol::StateTrigger *temp = state_trigger_;
  state_trigger_ = NULL;
  return temp;
}
inline void PersonInfo::set_allocated_state_trigger(
    ::DMSOutputProtocol::StateTrigger *state_trigger) {
  delete state_trigger_;
  state_trigger_ = state_trigger;
  if (state_trigger) {
    set_has_state_trigger();
  } else {
    clear_has_state_trigger();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.PersonInfo.state_trigger)
}

// -------------------------------------------------------------------

// VisionPercept

// required .DMSOutputProtocol.CameraType camera_type = 1;
inline bool VisionPercept::has_camera_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisionPercept::set_has_camera_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisionPercept::clear_has_camera_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisionPercept::clear_camera_type() {
  camera_type_ = 0;
  clear_has_camera_type();
}
inline ::DMSOutputProtocol::CameraType VisionPercept::camera_type() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.VisionPercept.camera_type)
  return static_cast< ::DMSOutputProtocol::CameraType>(camera_type_);
}
inline void VisionPercept::set_camera_type(
    ::DMSOutputProtocol::CameraType value) {
  assert(::DMSOutputProtocol::CameraType_IsValid(value));
  set_has_camera_type();
  camera_type_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.VisionPercept.camera_type)
}

// required int32 frame_id = 2;
inline bool VisionPercept::has_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisionPercept::set_has_frame_id() { _has_bits_[0] |= 0x00000002u; }
inline void VisionPercept::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisionPercept::clear_frame_id() {
  frame_id_ = 0;
  clear_has_frame_id();
}
inline ::google::protobuf::int32 VisionPercept::frame_id() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.VisionPercept.frame_id)
  return frame_id_;
}
inline void VisionPercept::set_frame_id(::google::protobuf::int32 value) {
  set_has_frame_id();
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.VisionPercept.frame_id)
}

// required sint64 time_stamp = 3;
inline bool VisionPercept::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VisionPercept::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VisionPercept::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VisionPercept::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::int64 VisionPercept::time_stamp() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.VisionPercept.time_stamp)
  return time_stamp_;
}
inline void VisionPercept::set_time_stamp(::google::protobuf::int64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:DMSOutputProtocol.VisionPercept.time_stamp)
}

// repeated .DMSOutputProtocol.PersonInfo person = 5;
inline int VisionPercept::person_size() const { return person_.size(); }
inline void VisionPercept::clear_person() { person_.Clear(); }
inline const ::DMSOutputProtocol::PersonInfo &VisionPercept::person(
    int index) const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.VisionPercept.person)
  return person_.Get(index);
}
inline ::DMSOutputProtocol::PersonInfo *VisionPercept::mutable_person(
    int index) {
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.VisionPercept.person)
  return person_.Mutable(index);
}
inline ::DMSOutputProtocol::PersonInfo *VisionPercept::add_person() {
  // @@protoc_insertion_point(field_add:DMSOutputProtocol.VisionPercept.person)
  return person_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<
    ::DMSOutputProtocol::PersonInfo>
    &VisionPercept::person() const {
  // @@protoc_insertion_point(field_list:DMSOutputProtocol.VisionPercept.person)
  return person_;
}
inline ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::PersonInfo>
    *VisionPercept::mutable_person() {
  // @@protoc_insertion_point(field_mutable_list:DMSOutputProtocol.VisionPercept.person)
  return &person_;
}

// required .DMSOutputProtocol.DAAResult daa_result = 6;
inline bool VisionPercept::has_daa_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VisionPercept::set_has_daa_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VisionPercept::clear_has_daa_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VisionPercept::clear_daa_result() {
  if (daa_result_ != NULL)
    daa_result_->::DMSOutputProtocol::DAAResult::Clear();
  clear_has_daa_result();
}
inline const ::DMSOutputProtocol::DAAResult &VisionPercept::daa_result() const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.VisionPercept.daa_result)
  return daa_result_ != NULL ? *daa_result_ : *default_instance_->daa_result_;
}
inline ::DMSOutputProtocol::DAAResult *VisionPercept::mutable_daa_result() {
  set_has_daa_result();
  if (daa_result_ == NULL)
    daa_result_ = new ::DMSOutputProtocol::DAAResult;
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.VisionPercept.daa_result)
  return daa_result_;
}
inline ::DMSOutputProtocol::DAAResult *VisionPercept::release_daa_result() {
  clear_has_daa_result();
  ::DMSOutputProtocol::DAAResult *temp = daa_result_;
  daa_result_ = NULL;
  return temp;
}
inline void VisionPercept::set_allocated_daa_result(
    ::DMSOutputProtocol::DAAResult *daa_result) {
  delete daa_result_;
  daa_result_ = daa_result;
  if (daa_result) {
    set_has_daa_result();
  } else {
    clear_has_daa_result();
  }
  // @@protoc_insertion_point(field_set_allocated:DMSOutputProtocol.VisionPercept.daa_result)
}

// -------------------------------------------------------------------

// PerceptResult

// repeated .DMSOutputProtocol.VisionPercept vision = 1;
inline int PerceptResult::vision_size() const { return vision_.size(); }
inline void PerceptResult::clear_vision() { vision_.Clear(); }
inline const ::DMSOutputProtocol::VisionPercept &PerceptResult::vision(
    int index) const {
  // @@protoc_insertion_point(field_get:DMSOutputProtocol.PerceptResult.vision)
  return vision_.Get(index);
}
inline ::DMSOutputProtocol::VisionPercept *PerceptResult::mutable_vision(
    int index) {
  // @@protoc_insertion_point(field_mutable:DMSOutputProtocol.PerceptResult.vision)
  return vision_.Mutable(index);
}
inline ::DMSOutputProtocol::VisionPercept *PerceptResult::add_vision() {
  // @@protoc_insertion_point(field_add:DMSOutputProtocol.PerceptResult.vision)
  return vision_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<
    ::DMSOutputProtocol::VisionPercept>
    &PerceptResult::vision() const {
  // @@protoc_insertion_point(field_list:DMSOutputProtocol.PerceptResult.vision)
  return vision_;
}
inline ::google::protobuf::RepeatedPtrField< ::DMSOutputProtocol::VisionPercept>
    *PerceptResult::mutable_vision() {
  // @@protoc_insertion_point(field_mutable_list:DMSOutputProtocol.PerceptResult.vision)
  return &vision_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DMSOutputProtocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
struct is_proto_enum< ::DMSOutputProtocol::ImageCheckEnum>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::ImageCheckEnum>() {
  return ::DMSOutputProtocol::ImageCheckEnum_descriptor();
}
template <>
struct is_proto_enum< ::DMSOutputProtocol::EyeState>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::EyeState>() {
  return ::DMSOutputProtocol::EyeState_descriptor();
}
template <>
struct is_proto_enum< ::DMSOutputProtocol::SmokeState>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::SmokeState>() {
  return ::DMSOutputProtocol::SmokeState_descriptor();
}
template <>
struct is_proto_enum< ::DMSOutputProtocol::StateEnum>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::StateEnum>() {
  return ::DMSOutputProtocol::StateEnum_descriptor();
}
template <>
struct is_proto_enum< ::DMSOutputProtocol::EventEnum>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::EventEnum>() {
  return ::DMSOutputProtocol::EventEnum_descriptor();
}
template <>
struct is_proto_enum< ::DMSOutputProtocol::FaceDirEnum>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::FaceDirEnum>() {
  return ::DMSOutputProtocol::FaceDirEnum_descriptor();
}
template <>
struct is_proto_enum< ::DMSOutputProtocol::PersonType>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::PersonType>() {
  return ::DMSOutputProtocol::PersonType_descriptor();
}
template <>
struct is_proto_enum< ::DMSOutputProtocol::CameraType>
    : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor< ::DMSOutputProtocol::CameraType>() {
  return ::DMSOutputProtocol::CameraType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DMSSDKOutput_2eproto__INCLUDED
